import {
  AddressLookupTableAccount,
  BlockhashWithExpiryBlockHeight,
  Commitment,
  ComputeBudgetProgram,
  Connection,
  RpcResponseAndContext,
  SimulatedTransactionResponse,
  TransactionInstruction,
  VersionedTransaction,
} from '@solana/web3.js';
import { Result, err, ok } from 'neverthrow';
import { AsyncSigner } from '../asyncSigner';
import { normalizeArray } from '../util';
import {
  COMPUTE_TEST_INSTRUCTIONS,
  COMPUTE_TEST_INSTRUCTION_RETURNS,
  GetPriorityFee,
  PriorityConfig,
  buildAndSignOptimalTransaction,
  buildOptimalDynamicTransactions,
  buildSimulationTransaction,
  getSimulationUnits,
  getWritableAccounts,
} from './compute';
import {
  InstructionsWithSignersAndLUTs,
  deepCopyInstructions,
  getNextFullTransaction,
} from './sizing';
import {
  InstructionReturn,
  TransactionReturn,
  buildAndSignTransactionsFromIxWithSigners,
  ixToIxReturn,
} from './transactionHandling';

export type InstructionCount = {
  max?: number;
  maxOnFail?: number;
};

export type AfterIx = {
  ix: InstructionReturn;
  computeEstimate: number;
  maxTraceCount: number;
};

export type MapLimit = (num: number) => number | undefined;

export type TransactionBuilderConstructor = {
  connection: Connection;
  feePayer: AsyncSigner;
  commitment?: Commitment;
  lookupTables?: AddressLookupTableAccount[];
  beforeIxs?: InstructionReturn[];
  afterIxs?: AfterIx[];
  instructionCount?: InstructionCount;
  mapLimit?: MapLimit;
  getFee?: GetPriorityFee;
};

export type MaybeArray<T> = T | T[];

export type TraceExceededError = {
  traceExceeded: number;
  unitsConsumed: number | undefined;
  ixTraces: number[];
};

export type BuiltConfigWithCompute = InstructionsWithSignersAndLUTs & {
  computeCount: number;
  beforeCount: number;
  afterCount: number;
};

export type NoSigningReturn = {
  lastBuilt: BuiltConfigWithCompute;
  rbh: BlockhashWithExpiryBlockHeight;
};

export type PriorityResult = {
  limit?: number;
  fee?: number;
};

export type ParseSimulationResult = Result<
  number | undefined,
  TraceExceededError | undefined | string
>;

export function checkTraceExceeded(
  simulation: RpcResponseAndContext<SimulatedTransactionResponse>
): TraceExceededError | undefined {
  const error = simulation.value.err;
  if (error) {
    if (typeof error == 'object' && 'InstructionError' in error) {
      const ixError = error.InstructionError;
      if (ixError && typeof ixError === 'object') {
        const isTrace =
          '1' in ixError &&
          typeof ixError[1] === 'string' &&
          ixError[1] === 'MaxInstructionTraceLengthExceeded';
        if (isTrace && '0' in ixError) {
          if (typeof ixError[0] === 'number') {
            const ixTraces: number[] = [];

            // const logs = simulation.value.logs;
            // if (logs) {
            //   for (const log of logs) {
            //     if (log.startsWith('Program log:')) {
            //       const split = log.split(' ');
            //       const ix = split[2];
            //       if (ix) {
            //         ixTraces.push(Number(ix));
            //       }
            //     }
            //   }
            // }
            return {
              traceExceeded: ixError[0],
              unitsConsumed: simulation.value.unitsConsumed,
              // todo: parse logs to get the ix trace count for each instruction
              ixTraces,
            };
          }
        }
      }
    }
  }
}

export class TransactionBuilderCore {
  public connection: Connection;
  public commitment: Commitment;
  public feePayer: AsyncSigner;
  public lookupTables: AddressLookupTableAccount[];
  public getFee?: GetPriorityFee;
  public mapLimit: MapLimit;
  protected beforeIxs: InstructionReturn[];
  protected afterIxs: AfterIx[];
  public instructionCountConfig: InstructionCount;
  public instructions: InstructionReturn[] = [];
  protected lastBuilt: BuiltConfigWithCompute | null = null;

  public lastTransaction: TransactionReturn | null = null;
  public lastTryIterations = 0;
  protected isBuildingNext = false;

  constructor(args: TransactionBuilderConstructor) {
    this.connection = args.connection;
    this.commitment =
      args.commitment ?? args.connection.commitment ?? 'confirmed';
    this.feePayer = args.feePayer;
    this.lookupTables = args.lookupTables ?? [];
    this.beforeIxs = args.beforeIxs ?? [];
    this.afterIxs = args.afterIxs ?? [];
    this.instructionCountConfig = {
      max: args.instructionCount?.max,
      maxOnFail: args.instructionCount?.maxOnFail,
    };
    const defaultLimit = (num: number) => {
      return num + Math.min(100_000, Math.max(10_000, num * 0.1));
    };
    this.mapLimit = args.mapLimit || defaultLimit;
    this.getFee = args.getFee;
  }

  public add(instruction: MaybeArray<InstructionReturn>): typeof this;
  public add(
    instruction: MaybeArray<TransactionInstruction>,
    signers?: AsyncSigner[]
  ): typeof this;

  public add(
    instruction:
      | MaybeArray<InstructionReturn>
      | MaybeArray<TransactionInstruction>,
    signers?: AsyncSigner[]
  ): typeof this {
    const instructions = normalizeArray(instruction);
    if (instructions.length === 0) {
      return this;
    }
    if (typeof instructions[0] === 'function') {
      this.instructions.push(...(instructions as InstructionReturn[]));
    } else {
      this.instructions.push(
        ...(instructions as TransactionInstruction[]).map((ix) => {
          let actualSigners: AsyncSigner[] | undefined = undefined;
          if (signers) {
            const signersKeys = ix.keys
              .filter((k) => k.isSigner)
              .map((k) => k.pubkey);
            actualSigners = signers.filter((s) =>
              signersKeys.some((k) => k.equals(s.publicKey()))
            );
          }
          return ixToIxReturn(ix, actualSigners);
        })
      );
    }
    return this;
  }

  protected getPopCount(buildConfig: BuiltConfigWithCompute): number {
    return (
      buildConfig.instructions.length -
      buildConfig.computeCount -
      buildConfig.beforeCount -
      buildConfig.afterCount
    );
  }

  protected resetIterations(): void {
    this.lastTryIterations = 0;
  }

  protected computeBeforeIxs(): InstructionReturn[] {
    return [...COMPUTE_TEST_INSTRUCTION_RETURNS, ...this.beforeIxs];
  }

  protected resetDummyComputeInstructions(builtConfig: BuiltConfigWithCompute) {
    builtConfig.instructions.splice(0, builtConfig.computeCount);
    builtConfig.computeCount = 2;
    builtConfig.instructions.unshift(
      ...COMPUTE_TEST_INSTRUCTIONS.map((ix) => {
        return {
          instruction: ix,
          signers: [],
        };
      })
    );
  }

  protected getLatestBlockhash(): Promise<BlockhashWithExpiryBlockHeight> {
    return this.connection.getLatestBlockhash({ commitment: this.commitment });
  }

  protected parseSimulationResult(
    simulation: RpcResponseAndContext<SimulatedTransactionResponse>
  ): ParseSimulationResult {
    const error = simulation.value.err;
    if (!error) {
      return ok(simulation.value?.unitsConsumed);
    }
    const maybeTrace = checkTraceExceeded(simulation);
    if (maybeTrace) {
      return err(maybeTrace);
    }
    return err(undefined);
  }

  protected async simulateTransaction(
    txn: VersionedTransaction
  ): Promise<ParseSimulationResult> {
    const commitment =
      this.commitment === 'processed' ? 'processed' : 'confirmed';
    const simulation = await this.connection.simulateTransaction(txn, {
      commitment,
      replaceRecentBlockhash: true,
    });
    return this.parseSimulationResult(simulation);
  }

  protected async handlePriorityOptimization(
    buildConfig: BuiltConfigWithCompute,
    ignoreError: boolean,
    depth: number,
    maxDepth = 3
  ): Promise<Result<PriorityResult, string>> {
    if (depth > maxDepth) {
      return err('Priority optimizer depth exceeded');
    }
    const txn = buildSimulationTransaction(
      buildConfig.instructions.map((i) => i.instruction),
      buildConfig.lookupTables,
      this.feePayer.publicKey()
    );
    const writableKeys = getWritableAccounts(
      buildConfig.instructions.map((i) => i.instruction)
    );

    this.lastTryIterations++;
    const [simulation, fee] = await Promise.all([
      this.simulateTransaction(txn),
      this.getFee
        ? await this.getFee(writableKeys, this.connection)
        : undefined,
    ]);
    let limit = undefined;
    if (simulation.isOk()) {
      const units = simulation.value;
      if (units !== undefined) {
        limit = this.mapLimit(units);
      }
    } else if (typeof simulation.error === 'string') {
      return err(simulation.error);
    } else if (!ignoreError) {
      const error = simulation.error;
      let doMaxOnFail = false;
      if (typeof error === 'string') {
        return err(error);
      } else if (error !== undefined) {
        const { traceExceeded, ixTraces, unitsConsumed } = error;
        if (buildConfig.afterCount === 0) {
          buildConfig.instructions.splice(traceExceeded - 1);
          return this.handlePriorityOptimization(buildConfig, true, depth + 1);
        } else {
          // todo: once 1.18 comes around, utilize innerInstructions from simulation
          doMaxOnFail = true;
        }
      } else {
        doMaxOnFail = true;
      }
      if (doMaxOnFail) {
        const maxOnFail = this.instructionCountConfig.maxOnFail ?? 14;
        if (buildConfig.instructions.length <= maxOnFail) {
          console.warn(
            'TransactionBuilder: simulation failed; instructions count is less than max on fail. Ignoring error...'
          );
        } else {
          const maxRemovable = this.getPopCount(buildConfig);
          let removeCount = buildConfig.instructions.length - maxOnFail;
          if (removeCount > maxRemovable) {
            console.warn(
              `TransactionBuilder: simulation failed; remove count is greater than max removable of ${maxRemovable}. Removing ${
                maxRemovable - 1
              } instructions`
            );
            removeCount = maxRemovable - 1;
          }
          buildConfig.instructions.splice(
            buildConfig.beforeCount + buildConfig.computeCount,
            removeCount
          );
          return this.handlePriorityOptimization(buildConfig, true, depth + 1);
        }
      }
    }

    return ok({ limit, fee });
  }

  protected replaceComputeInstructions(
    builtConfig: BuiltConfigWithCompute,
    priorityResult: PriorityResult
  ) {
    const { limit, fee } = priorityResult;
    // remove dummy compute instructions
    builtConfig.instructions.splice(0, builtConfig.computeCount);
    builtConfig.computeCount = 0;
    if (limit !== undefined) {
      builtConfig.instructions.unshift({
        instruction: ComputeBudgetProgram.setComputeUnitLimit({
          units: limit,
        }),
        signers: [],
      });
      builtConfig.computeCount++;
    }
    if (fee !== undefined) {
      builtConfig.instructions.unshift({
        instruction: ComputeBudgetProgram.setComputeUnitPrice({
          microLamports: fee,
        }),
        signers: [],
      });
      builtConfig.computeCount++;
    }
  }

  protected startBuildingNext(): void {
    if (this.isBuildingNext) {
      throw new Error('Already building next optimal transaction');
    }
    this.isBuildingNext = true;
  }

  // todo: figure out a better error type for this. String doesnt cut it
  protected async buildNextOptimalTransactionNoSigning(): Promise<
    Result<NoSigningReturn, string>
  > {
    this.resetIterations();
    const beforeIxs = this.computeBeforeIxs();
    const next = await getNextFullTransaction(
      this.instructions,
      this.feePayer,
      beforeIxs,
      this.afterIxs.map((ix) => ix.ix),
      this.lookupTables,
      this.instructionCountConfig.max
    );

    if (next.isErr()) {
      return err(next.error);
    }
    const [ixs] = next.value;

    const buildConfig = {
      ...ixs,
      computeCount: COMPUTE_TEST_INSTRUCTION_RETURNS.length,
      beforeCount: this.beforeIxs.length,
      afterCount: this.afterIxs.length,
    };

    const [priorityResult, rbh] = await Promise.all([
      this.handlePriorityOptimization(buildConfig, false, 0),
      this.getLatestBlockhash(),
    ]);
    if (priorityResult.isErr()) {
      return err(priorityResult.error);
    }
    const { fee, limit } = priorityResult.value;
    this.replaceComputeInstructions(buildConfig, { limit, fee });

    const lastBuilt = {
      ...buildConfig,
      ...deepCopyInstructions(buildConfig),
    };

    return ok({
      // ixs,
      rbh,
      lastBuilt,
    });
  }

  async rebuildLastNoSigning(
    recalculatePriority: boolean
  ): Promise<Result<NoSigningReturn, string>> {
    this.resetIterations();
    if (this.lastBuilt === null) {
      return err('No last built transaction to rebuild');
    }
    const lastBuiltCopy = {
      ...this.lastBuilt,
      ...deepCopyInstructions(this.lastBuilt),
    };

    let rbh: BlockhashWithExpiryBlockHeight;
    if (recalculatePriority) {
      this.resetDummyComputeInstructions(lastBuiltCopy);
      const oldPopCount = this.getPopCount(lastBuiltCopy);
      const [priorityRes, recentBlockhash] = await Promise.all([
        this.handlePriorityOptimization(lastBuiltCopy, false, 0, 1),
        this.getLatestBlockhash(),
      ]);
      rbh = recentBlockhash;
      if (priorityRes.isErr()) {
        return err(priorityRes.error);
      }
      const { fee, limit } = priorityRes.value;
      const newPopCount = this.getPopCount(lastBuiltCopy);

      if (newPopCount !== oldPopCount) {
        console.warn(
          `TransactionBuilder: pop count changed from ${oldPopCount} to ${newPopCount} in rebuildLastBuilt`
        );
      }
      this.replaceComputeInstructions(lastBuiltCopy, { limit, fee });
    } else {
      rbh = await this.getLatestBlockhash();
    }

    return ok({
      lastBuilt: lastBuiltCopy,
      rbh,
    });
  }

  handlePostBuild(
    txReturn: TransactionReturn,
    lastBuilt: BuiltConfigWithCompute
  ): void {
    const popCount = this.getPopCount(lastBuilt);
    if (popCount <= 0) {
      throw new Error(
        'TransactionBuilder: pop count is less than or equal to 0'
      );
    }
    this.instructions.splice(0, this.getPopCount(lastBuilt));
    this.lastBuilt = lastBuilt;
    this.lastTransaction = txReturn;
  }

  clear(): InstructionReturn[] {
    return this.instructions.splice(0, this.instructions.length);
  }
}

export type TransactionReturnIterator = AsyncIterableIterator<
  Result<TransactionReturn, string>
>;

export async function* transactionReturnIterator(
  transactions: Result<TransactionReturn[], string>
): TransactionReturnIterator {
  if (transactions.isErr()) {
    yield err(transactions.error);
  } else {
    for (const transaction of transactions.value) {
      yield ok(transaction);
    }
  }
}

export class TransactionBuilder extends TransactionBuilderCore {
  constructor(args: TransactionBuilderConstructor) {
    super(args);
  }

  async *optimalTransactions(): TransactionReturnIterator {
    while (this.instructions.length > 0) {
      yield this.buildNextOptimalTransaction();
    }
  }

  async buildNextOptimalTransaction(): Promise<
    Result<TransactionReturn, string>
  > {
    this.startBuildingNext();
    try {
      const res = await this.buildNextOptimalTransactionNoSigning();
      if (res.isErr()) {
        return err(res.error);
      }
      const { rbh, lastBuilt } = res.value;

      const toReturn = (
        await buildAndSignTransactionsFromIxWithSigners(
          [
            {
              ixs: lastBuilt.instructions,
              lookupTables: lastBuilt.lookupTables,
              connectionOrRbh: {
                rbh,
                commitment: this.commitment,
              },
            },
          ],
          this.feePayer
        )
      )[0];
      this.handlePostBuild(toReturn, lastBuilt);
      return ok(toReturn);
    } finally {
      this.isBuildingNext = false;
    }
  }

  async rebuildLast(
    recalculatePriority = true
  ): Promise<Result<TransactionReturn, string>> {
    const res = await this.rebuildLastNoSigning(recalculatePriority);
    if (res.isErr()) {
      return err(res.error);
    }

    const { lastBuilt, rbh } = res.value;

    const toReturn = (
      await buildAndSignTransactionsFromIxWithSigners(
        [
          {
            ixs: lastBuilt.instructions,
            lookupTables: lastBuilt.lookupTables,
            connectionOrRbh: {
              rbh,
              commitment: this.commitment,
            },
          },
        ],
        this.feePayer
      )
    )[0];
    return ok(toReturn);
  }

  buildDynamic(): Promise<Result<TransactionReturn[], string>> {
    return buildOptimalDynamicTransactions(
      this.connection,
      this.instructions,
      this.feePayer,
      {
        getFee: this.getFee,
        getLimit: (...args) =>
          getSimulationUnits(...args).then((units) => {
            if (units !== undefined) {
              return this.mapLimit(units);
            }
          }),
      },
      this.lookupTables,
      this.beforeIxs,
      this.afterIxs.map((ix) => ix.ix),
      this.instructionCountConfig.max
    );
  }

  buildAndSignOptimal(): Promise<TransactionReturn> {
    const instructions = [
      ...this.beforeIxs,
      ...this.instructions,
      ...this.afterIxs.map((ix) => ix.ix),
    ];
    const priorityConfig: PriorityConfig = {
      getLimit: (...args) =>
        getSimulationUnits(...args).then((units) => {
          if (units !== undefined) {
            return this.mapLimit(units);
          }
        }),
      getFee: this.getFee ?? undefined,
    };
    return buildAndSignOptimalTransaction(
      this.connection,
      instructions,
      this.feePayer,
      priorityConfig,
      this.lookupTables
    );
  }
}
