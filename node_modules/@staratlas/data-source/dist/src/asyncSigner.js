"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDummyAsyncSigner = exports.signerToAsyncSigner = exports.walletToAsyncSigner = exports.keypairToAsyncSigner = exports.isAsyncSigner = void 0;
function isAsyncSigner(obj) {
    return ('inner' in obj &&
        'requiresAsync' in obj &&
        'publicKey' in obj &&
        'sign' in obj &&
        'signAll' in obj);
}
exports.isAsyncSigner = isAsyncSigner;
function partialSign(tx, signer) {
    if ('instructions' in tx) {
        tx.partialSign(signer);
    }
    else {
        tx.sign([signer]);
    }
}
function keypairToAsyncSigner(keypair) {
    return {
        inner: () => keypair,
        requiresAsync() {
            return false;
        },
        publicKey() {
            return keypair.publicKey;
        },
        sign: (tx) => {
            partialSign(tx, keypair);
            return Promise.resolve(tx);
        },
        signAll: (txs) => {
            for (const tx of txs) {
                partialSign(tx, keypair);
            }
            return Promise.resolve(txs);
        },
    };
}
exports.keypairToAsyncSigner = keypairToAsyncSigner;
function walletToAsyncSigner(wallet) {
    return {
        inner() {
            return wallet;
        },
        publicKey() {
            return wallet.publicKey;
        },
        requiresAsync() {
            return true;
        },
        sign(tx) {
            return wallet.signTransaction(tx);
        },
        signAll(txs) {
            return wallet.signAllTransactions(txs);
        },
    };
}
exports.walletToAsyncSigner = walletToAsyncSigner;
function signerToAsyncSigner(signer) {
    return {
        inner: () => signer,
        publicKey: () => signer.publicKey,
        requiresAsync: () => false,
        sign: (tx) => {
            partialSign(tx, signer);
            return Promise.resolve(tx);
        },
        signAll: (txs) => {
            for (const tx of txs) {
                partialSign(tx, signer);
            }
            return Promise.resolve(txs);
        },
    };
}
exports.signerToAsyncSigner = signerToAsyncSigner;
function createDummyAsyncSigner(debugAddress) {
    return {
        requiresAsync() {
            return false;
        },
        publicKey() {
            return debugAddress;
        },
        sign: (tx) => {
            tx.addSignature(debugAddress, Buffer.alloc(64));
            return Promise.resolve(tx);
        },
        signAll: (txs) => {
            for (const tx of txs) {
                tx.addSignature(debugAddress, Buffer.alloc(64));
            }
            return Promise.resolve(txs);
        },
    };
}
exports.createDummyAsyncSigner = createDummyAsyncSigner;
//# sourceMappingURL=asyncSigner.js.map