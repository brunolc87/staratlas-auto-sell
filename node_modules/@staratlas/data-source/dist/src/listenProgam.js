"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListenProgram = void 0;
const anchor_1 = require("@staratlas/anchor");
const util_1 = require("./util");
class ListenProgram {
    constructor(program, parsers) {
        this.program = program;
        this.parsers = parsers;
        this.accountClosedListener = null;
        this.accountDiscriminants = (0, util_1.remapObject)(parsers, (value) => anchor_1.BorshAccountsCoder.accountDiscriminator(value.ACCOUNT_NAME));
        this.listeners = (0, util_1.remapObject)(parsers, () => null);
    }
    setAccountClosedListener(listener) {
        this.accountClosedListener = listener;
    }
    get programId() {
        return this.program.programId;
    }
    accountDiscriminant(accountId) {
        return this.accountDiscriminants[accountId];
    }
    discriminantToAccountId(data) {
        for (const [key, value] of Object.entries(this.accountDiscriminants)) {
            if (data.subarray(0, value.length).equals(value)) {
                return {
                    key: key,
                    discriminantLength: value.length,
                };
            }
        }
        return null;
    }
    provideDecodedAccountEvent(accountId, account, slot, confirmationStatus, isStartup, accountInfo, writeVersion) {
        const listener = this.listeners[accountId];
        if (listener) {
            listener({
                account,
                slot,
                confirmationStatus,
                isStartup,
                accountInfo,
                writeVersion,
            });
        }
    }
    provideAccountEvent(account, slot, confirmationStatus, isStartup, writeVersion, unknownAccountHandler = (key) => {
        console.error(`Unknown account \`${key.toBase58()}\` for program \`${this.programId.toBase58()}\``);
    }) {
        const accountId = this.discriminantToAccountId(account.accountInfo.data);
        if (accountId === null) {
            unknownAccountHandler(account.accountId);
            return;
        }
        if (this.listeners[accountId.key]) {
            const decoded = this.parsers[accountId.key].decodeData(account, this.program);
            if ('error' in decoded) {
                throw decoded.error;
            }
            this.provideDecodedAccountEvent(accountId.key, decoded.data, slot, confirmationStatus, isStartup, account.accountInfo, writeVersion);
        }
    }
    setAccountListener(accountId, accountType, listener) {
        if (listener) {
            this.listeners[accountId] = (update) => {
                if (update.account instanceof accountType) {
                    listener(Object.assign(Object.assign({}, update), { account: update.account }));
                }
                else {
                    console.error('Wrong account type passed, account: ', JSON.stringify(update.account));
                }
            };
        }
        else {
            this.listeners[accountId] = null;
        }
    }
    discriminantToAccountIdNoSubarray(discriminant) {
        const keys = Object.keys(this.accountDiscriminants);
        for (const key of keys) {
            const value = this.accountDiscriminants[key];
            if (discriminant.equals(value)) {
                return {
                    key: key,
                    discriminantLength: value.length,
                };
            }
        }
        return null;
    }
    provideAccountClosedEvent(key, oldOwner, newOwner, slot, confirmationStatus, writeVersion, accountInfo) {
        const listener = this.accountClosedListener;
        if (listener) {
            listener({
                accountInfo,
                slot,
                confirmationStatus,
                writeVersion,
                key,
                oldOwner,
                newOwner,
            });
        }
    }
}
exports.ListenProgram = ListenProgram;
//# sourceMappingURL=listenProgam.js.map