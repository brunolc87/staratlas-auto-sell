import { AddressLookupTableAccount, BlockhashWithExpiryBlockHeight, Commitment, Connection, RpcResponseAndContext, SimulatedTransactionResponse, TransactionInstruction, VersionedTransaction } from '@solana/web3.js';
import { Result } from 'neverthrow';
import { AsyncSigner } from '../asyncSigner';
import { GetPriorityFee } from './compute';
import { InstructionsWithSignersAndLUTs } from './sizing';
import { InstructionReturn, TransactionReturn } from './transactionHandling';
export type InstructionCount = {
    max?: number;
    maxOnFail?: number;
};
export type AfterIx = {
    ix: InstructionReturn;
    computeEstimate: number;
    maxTraceCount: number;
};
export type MapLimit = (num: number) => number | undefined;
export type TransactionBuilderConstructor = {
    connection: Connection;
    feePayer: AsyncSigner;
    commitment?: Commitment;
    lookupTables?: AddressLookupTableAccount[];
    beforeIxs?: InstructionReturn[];
    afterIxs?: AfterIx[];
    instructionCount?: InstructionCount;
    mapLimit?: MapLimit;
    getFee?: GetPriorityFee;
};
export type MaybeArray<T> = T | T[];
export type TraceExceededError = {
    traceExceeded: number;
    unitsConsumed: number | undefined;
    ixTraces: number[];
};
export type BuiltConfigWithCompute = InstructionsWithSignersAndLUTs & {
    computeCount: number;
    beforeCount: number;
    afterCount: number;
};
export type NoSigningReturn = {
    lastBuilt: BuiltConfigWithCompute;
    rbh: BlockhashWithExpiryBlockHeight;
};
export type PriorityResult = {
    limit?: number;
    fee?: number;
};
export type ParseSimulationResult = Result<number | undefined, TraceExceededError | undefined | string>;
export declare function checkTraceExceeded(simulation: RpcResponseAndContext<SimulatedTransactionResponse>): TraceExceededError | undefined;
export declare class TransactionBuilderCore {
    connection: Connection;
    commitment: Commitment;
    feePayer: AsyncSigner;
    lookupTables: AddressLookupTableAccount[];
    getFee?: GetPriorityFee;
    mapLimit: MapLimit;
    protected beforeIxs: InstructionReturn[];
    protected afterIxs: AfterIx[];
    instructionCountConfig: InstructionCount;
    instructions: InstructionReturn[];
    protected lastBuilt: BuiltConfigWithCompute | null;
    lastTransaction: TransactionReturn | null;
    lastTryIterations: number;
    protected isBuildingNext: boolean;
    constructor(args: TransactionBuilderConstructor);
    add(instruction: MaybeArray<InstructionReturn>): typeof this;
    add(instruction: MaybeArray<TransactionInstruction>, signers?: AsyncSigner[]): typeof this;
    protected getPopCount(buildConfig: BuiltConfigWithCompute): number;
    protected resetIterations(): void;
    protected computeBeforeIxs(): InstructionReturn[];
    protected resetDummyComputeInstructions(builtConfig: BuiltConfigWithCompute): void;
    protected getLatestBlockhash(): Promise<BlockhashWithExpiryBlockHeight>;
    protected parseSimulationResult(simulation: RpcResponseAndContext<SimulatedTransactionResponse>): ParseSimulationResult;
    protected simulateTransaction(txn: VersionedTransaction): Promise<ParseSimulationResult>;
    protected handlePriorityOptimization(buildConfig: BuiltConfigWithCompute, ignoreError: boolean, depth: number, maxDepth?: number): Promise<Result<PriorityResult, string>>;
    protected replaceComputeInstructions(builtConfig: BuiltConfigWithCompute, priorityResult: PriorityResult): void;
    protected startBuildingNext(): void;
    protected buildNextOptimalTransactionNoSigning(): Promise<Result<NoSigningReturn, string>>;
    rebuildLastNoSigning(recalculatePriority: boolean): Promise<Result<NoSigningReturn, string>>;
    handlePostBuild(txReturn: TransactionReturn, lastBuilt: BuiltConfigWithCompute): void;
    clear(): InstructionReturn[];
}
export type TransactionReturnIterator = AsyncIterableIterator<Result<TransactionReturn, string>>;
export declare function transactionReturnIterator(transactions: Result<TransactionReturn[], string>): TransactionReturnIterator;
export declare class TransactionBuilder extends TransactionBuilderCore {
    constructor(args: TransactionBuilderConstructor);
    optimalTransactions(): TransactionReturnIterator;
    buildNextOptimalTransaction(): Promise<Result<TransactionReturn, string>>;
    rebuildLast(recalculatePriority?: boolean): Promise<Result<TransactionReturn, string>>;
    buildDynamic(): Promise<Result<TransactionReturn[], string>>;
    buildAndSignOptimal(): Promise<TransactionReturn>;
}
//# sourceMappingURL=builder.d.ts.map