import { AddressLookupTableAccount, BlockhashWithExpiryBlockHeight, Commitment, CompileV0Args, Connection, Finality, GetAccountKeysArgs, PublicKey, RpcResponseAndContext, SendOptions, SerializeConfig, SignatureResult, TransactionError, TransactionInstruction, TransactionSignature, VersionedTransaction, type Transaction } from '@solana/web3.js';
import { Result } from 'neverthrow';
import { AsyncSigner } from '../asyncSigner';
import { TransactionSender } from './transactionSender';
export type AnyTransaction = VersionedTransaction | Transaction;
export declare function isVersionedTransaction(transaction: Transaction | VersionedTransaction): transaction is VersionedTransaction;
export declare function verifySignatures(tx: AnyTransaction): void;
export declare function getSignature(tx: AnyTransaction): TransactionSignature | undefined;
export type TransactionReturn<T extends AnyTransaction = VersionedTransaction> = {
    transaction: T;
    rbh: BlockhashWithExpiryBlockHeight;
    commitment: Commitment;
};
export type InstructionWithSigners = {
    instruction: TransactionInstruction;
    signers: AsyncSigner[];
};
export type InstructionReturn = (funder: AsyncSigner) => Promise<InstructionWithSigners | InstructionWithSigners[]>;
export declare function ixToIxReturn(ix: TransactionInstruction, signers?: AsyncSigner[]): InstructionReturn;
export declare function ixReturnsToIxs(ixReturns: InstructionReturn | InstructionReturn[], feePayer: AsyncSigner): Promise<TransactionInstruction[]>;
export type ConnectionOrRbh = {
    connection: TransactionSender;
    commitment?: Commitment;
} | {
    rbh: BlockhashWithExpiryBlockHeight;
    commitment: Commitment;
};
export type BuildTransactionsType<T = InstructionWithSigners | InstructionWithSigners[]> = {
    ixs: T;
    connectionOrRbh: ConnectionOrRbh;
    lookupTables?: AddressLookupTableAccount[];
};
export type SendTransactionOptions = {
    commitment?: Finality;
    sendOptions?: SendOptions;
};
export declare function buildAndSignTransaction(instructions: InstructionReturn | InstructionReturn[], feePayer: AsyncSigner, connectionOrRbh: ConnectionOrRbh, lookupTables?: AddressLookupTableAccount[]): Promise<TransactionReturn>;
export declare function buildAndSignTransactions(transactions: BuildTransactionsType<InstructionReturn | InstructionReturn[]>[], feePayer: AsyncSigner): Promise<TransactionReturn[]>;
export declare function formatExplorerMessageLink(transaction: AnyTransaction, connection: Connection): string;
export declare function formatExplorerLink(signature: TransactionSignature | string, connection: Connection): string;
export type SignerMap = Map<string, SignerEntry>;
export type SignerEntry = {
    signer: AsyncSigner;
    transactions: Set<number>;
};
export type BuildTransactionReturn = Omit<TransactionReturn, 'transaction'> & {
    compileArgs: CompileV0Args;
};
export declare function convertBuildTransactionReturn(tx: BuildTransactionReturn): TransactionReturn;
export declare function buildTransactionsFromIxWithSigners(transactions: BuildTransactionsType[], feePayer: {
    signer: AsyncSigner;
} | {
    key: PublicKey;
}): Promise<{
    tx: BuildTransactionReturn[];
    signers: SignerMap;
}>;
export declare function signTransactionReturns<T extends AnyTransaction>(unsignedTransactions: TransactionReturn<T>[], signers: SignerMap): Promise<TransactionReturn<T>[]>;
export declare function buildAndSignTransactionsFromIxWithSigners(transactions: BuildTransactionsType[], feePayer: AsyncSigner): Promise<TransactionReturn[]>;
/**
 * @deprecated Use {@link sendTransaction} instead.
 */
export declare function sendAndConfirmTransaction(tx: TransactionReturn, connection: TransactionSender, sendOptions?: SendOptions, serializeConfig?: SerializeConfig): Promise<{
    signature: TransactionSignature;
    signatureResult: SignatureResult;
}>;
/**
 * Sends and confirms a transaction
 * @param transaction The transaction to send
 * @param connection The connection to send the transaction to
 * @param options Options to send transaction
 * @param retryInterval How often to resend the transaction before it's confirmed, in ms. Default is 3000
 * @param maxRetries How many times to retry before giving up. Default is 10
 */
export declare function sendTransaction(transaction: TransactionReturn<AnyTransaction>, connection: TransactionSender, options?: SendTransactionOptions, retryInterval?: number, maxRetries?: number): Promise<RpcResponseAndContext<Result<TransactionSignature, TransactionError>>>;
/**
 * @deprecated Use {@link buildAndSignTransaction} and {@link sendTransaction} instead.
 * @param instructions
 * @param feePayer
 * @param connection
 * @param options
 * @param lookupTables
 */
export declare function buildSendAndCheck(instructions: InstructionReturn | InstructionReturn[], feePayer: AsyncSigner, connection: Connection, options?: {
    commitment?: Finality;
    sendOptions?: SendOptions;
    serializeConfig?: SerializeConfig;
    suppressLogging?: boolean;
    postTransactionHandler?: (tx: TransactionReturn) => TransactionReturn | void;
}, lookupTables?: AddressLookupTableAccount[]): Promise<TransactionSignature>;
export type PrettyTransaction = {
    instructions: PrettyInstruction[];
    signatures: PrettySignature[];
    feePayer: string | undefined;
    recentBlockhash: string | undefined;
};
export type PrettyInstruction = {
    keys: {
        isSigner: boolean;
        isWritable: boolean;
        pubkey: string | undefined;
    }[];
    programId: string | undefined;
};
export type PrettySignature = {
    signature: boolean;
    publicKey: string | undefined;
};
export declare function prettyTransaction(tx: AnyTransaction, accountKeyArgs?: GetAccountKeysArgs): PrettyTransaction;
//# sourceMappingURL=transactionHandling.d.ts.map