"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prettyTransaction = exports.buildSendAndCheck = exports.sendTransaction = exports.sendAndConfirmTransaction = exports.buildAndSignTransactionsFromIxWithSigners = exports.signTransactionReturns = exports.buildTransactionsFromIxWithSigners = exports.convertBuildTransactionReturn = exports.formatExplorerLink = exports.formatExplorerMessageLink = exports.buildAndSignTransactions = exports.buildAndSignTransaction = exports.ixReturnsToIxs = exports.ixToIxReturn = exports.getSignature = exports.verifySignatures = exports.isVersionedTransaction = void 0;
const ed25519_1 = require("@noble/curves/ed25519");
const web3_js_1 = require("@solana/web3.js");
const assert_1 = __importDefault(require("assert"));
const bs58_1 = __importDefault(require("bs58"));
const neverthrow_1 = require("neverthrow");
const util_1 = require("../util");
function isVersionedTransaction(transaction) {
    return 'version' in transaction;
}
exports.isVersionedTransaction = isVersionedTransaction;
function verifySignatures(tx) {
    if (isVersionedTransaction(tx)) {
        const serializedMessage = tx.message.serialize();
        for (const [index, signature] of tx.signatures.entries()) {
            const key = tx.message.staticAccountKeys[index];
            if (signature.every((byte) => byte === 0)) {
                throw new Error(`Missing required signature for key ${key} at index ${index}`);
            }
            else if (!ed25519_1.ed25519.verify(signature, serializedMessage, key.toBytes())) {
                throw new Error(`Signature ${index} failed to verify for key ${key}`);
            }
        }
    }
    else {
        tx.serialize();
    }
}
exports.verifySignatures = verifySignatures;
function getSignature(tx) {
    const sig = isVersionedTransaction(tx) ? tx.signatures[0] : tx.signature;
    return sig ? bs58_1.default.encode(sig) : undefined;
}
exports.getSignature = getSignature;
function ixToIxReturn(ix, signers = []) {
    // eslint-disable-next-line require-await
    return () => __awaiter(this, void 0, void 0, function* () {
        return ({
            signers,
            instruction: ix,
        });
    });
}
exports.ixToIxReturn = ixToIxReturn;
function ixReturnsToIxs(ixReturns, feePayer) {
    return __awaiter(this, void 0, void 0, function* () {
        const ixs = yield Promise.all((0, util_1.normalizeArray)(ixReturns).map((ixReturn) => ixReturn(feePayer)));
        return ixs.flat().map((ix) => ix.instruction);
    });
}
exports.ixReturnsToIxs = ixReturnsToIxs;
function buildAndSignTransaction(instructions, feePayer, connectionOrRbh, lookupTables = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const out = (yield buildAndSignTransactions([{ ixs: instructions, connectionOrRbh, lookupTables }], feePayer))[0];
        if (out === undefined) {
            throw new Error('Transaction was not built correctly');
        }
        return out;
    });
}
exports.buildAndSignTransaction = buildAndSignTransaction;
function buildAndSignTransactions(transactions, feePayer) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield buildAndSignTransactionsFromIxWithSigners(yield Promise.all(transactions.map(({ ixs, connectionOrRbh, lookupTables }) => __awaiter(this, void 0, void 0, function* () {
            return {
                ixs: (0, util_1.normalizeArray)(yield Promise.all((0, util_1.normalizeArray)(ixs).map((ix) => ix(feePayer)))).flat(),
                connectionOrRbh,
                lookupTables,
            };
        }))), feePayer);
    });
}
exports.buildAndSignTransactions = buildAndSignTransactions;
function formatExplorerMessageLink(transaction, connection) {
    const clusterUrl = encodeURIComponent(connection.rpcEndpoint);
    let serializedMessage;
    if (isVersionedTransaction(transaction)) {
        serializedMessage = Buffer.from(transaction.message.serialize());
    }
    else {
        serializedMessage = transaction.serializeMessage();
    }
    const message = encodeURIComponent(serializedMessage.toString('base64'));
    return `https://explorer.solana.com/tx/inspector?message=${message}&cluster=custom&customUrl=${clusterUrl}`;
}
exports.formatExplorerMessageLink = formatExplorerMessageLink;
function formatExplorerLink(signature, connection) {
    const clusterUrl = encodeURIComponent(connection.rpcEndpoint);
    return `https://explorer.solana.com/tx/${signature}?cluster=custom&customUrl=${clusterUrl}`;
}
exports.formatExplorerLink = formatExplorerLink;
function convertBuildTransactionReturn(tx) {
    const message = web3_js_1.MessageV0.compile(tx.compileArgs);
    const transaction = new web3_js_1.VersionedTransaction(message);
    return Object.assign(Object.assign({}, tx), { transaction });
}
exports.convertBuildTransactionReturn = convertBuildTransactionReturn;
function buildTransactionsFromIxWithSigners(transactions, feePayer) {
    return __awaiter(this, void 0, void 0, function* () {
        const signers = new Map();
        if ('signer' in feePayer) {
            const feePayerKey = feePayer.signer.publicKey().toBase58();
            const feePayerEntry = {
                signer: feePayer.signer,
                transactions: new Set(),
            };
            for (let x = 0; x < transactions.length; x++) {
                feePayerEntry.transactions.add(x);
            }
            signers.set(feePayerKey, feePayerEntry);
        }
        const feePayerKey = 'signer' in feePayer ? feePayer.signer.publicKey() : feePayer.key;
        return {
            tx: yield Promise.all(transactions.map(({ ixs: ixArray, connectionOrRbh, lookupTables }, index) => __awaiter(this, void 0, void 0, function* () {
                const instructions = (0, util_1.normalizeArray)(ixArray);
                for (const signer of instructions.flatMap((ix) => ix.signers)) {
                    const key = signer.publicKey().toBase58();
                    const signerEntry = signers.get(key);
                    if (signerEntry === undefined) {
                        signers.set(key, { signer, transactions: new Set([index]) });
                    }
                    else {
                        signerEntry.transactions.add(index);
                    }
                }
                let rbh;
                let commitment;
                if ('connection' in connectionOrRbh) {
                    rbh = yield connectionOrRbh.connection.getLatestBlockhash(connectionOrRbh.commitment);
                    commitment =
                        connectionOrRbh.commitment ||
                            connectionOrRbh.connection.commitment ||
                            'processed';
                }
                else {
                    rbh = connectionOrRbh.rbh;
                    commitment = connectionOrRbh.commitment;
                }
                const ixs = instructions.map((ix) => ix.instruction);
                const returnArgs = {
                    compileArgs: {
                        addressLookupTableAccounts: lookupTables,
                        instructions: [...ixs],
                        payerKey: feePayerKey,
                        recentBlockhash: rbh.blockhash,
                    },
                    commitment,
                    rbh,
                };
                return returnArgs;
            }))),
            signers,
        };
    });
}
exports.buildTransactionsFromIxWithSigners = buildTransactionsFromIxWithSigners;
function signTransactionReturns(unsignedTransactions, signers) {
    return __awaiter(this, void 0, void 0, function* () {
        const signTxns = ({ signer, transactions }) => __awaiter(this, void 0, void 0, function* () {
            const txsToSign = unsignedTransactions
                .map((tx, index) => ({ tx, index }))
                .filter(({ index }) => transactions.has(index));
            const newTxs = yield signer.signAll(txsToSign.map(({ tx }) => tx.transaction));
            (0, assert_1.default)(newTxs.length === txsToSign.length);
            for (let x = 0; x < txsToSign.length; x++) {
                unsignedTransactions[txsToSign[x].index].transaction = newTxs[x];
            }
        });
        for (const signer of signers.values()) {
            if (signer.signer.requiresAsync()) {
                yield signTxns(signer);
            }
        }
        for (const signer of signers.values()) {
            if (!signer.signer.requiresAsync()) {
                yield signTxns(signer);
            }
        }
        return unsignedTransactions;
    });
}
exports.signTransactionReturns = signTransactionReturns;
function buildAndSignTransactionsFromIxWithSigners(transactions, feePayer) {
    return __awaiter(this, void 0, void 0, function* () {
        const { tx: unsignedMessage, signers } = yield buildTransactionsFromIxWithSigners(transactions, {
            signer: feePayer,
        });
        const unsignedTransactions = unsignedMessage.map((tx) => convertBuildTransactionReturn(tx));
        return signTransactionReturns(unsignedTransactions, signers);
    });
}
exports.buildAndSignTransactionsFromIxWithSigners = buildAndSignTransactionsFromIxWithSigners;
/**
 * @deprecated Use {@link sendTransaction} instead.
 */
function sendAndConfirmTransaction(tx, connection, sendOptions, serializeConfig) {
    return __awaiter(this, void 0, void 0, function* () {
        const signature = yield connection.sendRawTransaction(tx.transaction.serialize(), sendOptions);
        return {
            signature,
            signatureResult: (yield connection.confirmTransaction(Object.assign(Object.assign({}, tx.rbh), { signature: signature }), tx.commitment)).value,
        };
    });
}
exports.sendAndConfirmTransaction = sendAndConfirmTransaction;
/**
 * Sends and confirms a transaction
 * @param transaction The transaction to send
 * @param connection The connection to send the transaction to
 * @param options Options to send transaction
 * @param retryInterval How often to resend the transaction before it's confirmed, in ms. Default is 3000
 * @param maxRetries How many times to retry before giving up. Default is 10
 */
function sendTransaction(transaction, connection, options, retryInterval = 3000, maxRetries = 10) {
    return __awaiter(this, void 0, void 0, function* () {
        const rawTransaction = transaction.transaction.serialize();
        if (isVersionedTransaction(transaction.transaction)) {
            verifySignatures(transaction.transaction);
        }
        const commitment = (options === null || options === void 0 ? void 0 : options.commitment) || 'confirmed';
        const signature = yield connection.sendRawTransaction(rawTransaction, options === null || options === void 0 ? void 0 : options.sendOptions);
        let count = 0;
        const interval = setInterval(() => {
            if (count < maxRetries) {
                void connection.sendRawTransaction(rawTransaction, Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.sendOptions), { skipPreflight: true }));
            }
            count++;
        }, retryInterval);
        let result;
        try {
            result = yield connection.confirmTransaction(Object.assign({ signature }, transaction.rbh), commitment);
        }
        finally {
            clearInterval(interval);
        }
        if (result.value.err !== null) {
            return { context: result.context, value: (0, neverthrow_1.err)(result.value.err) };
        }
        else {
            return { context: result.context, value: (0, neverthrow_1.ok)(signature) };
        }
    });
}
exports.sendTransaction = sendTransaction;
/**
 * @deprecated Use {@link buildAndSignTransaction} and {@link sendTransaction} instead.
 * @param instructions
 * @param feePayer
 * @param connection
 * @param options
 * @param lookupTables
 */
function buildSendAndCheck(instructions, feePayer, connection, options, lookupTables) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        instructions = (0, util_1.normalizeArray)(instructions);
        const commitment = (options === null || options === void 0 ? void 0 : options.commitment) || 'confirmed';
        let tx = yield buildAndSignTransaction(instructions, feePayer, {
            connection,
            commitment,
        }, lookupTables);
        if (options === null || options === void 0 ? void 0 : options.postTransactionHandler) {
            const newTx = options.postTransactionHandler(tx);
            if (newTx) {
                tx = newTx;
            }
        }
        const { signature, signatureResult } = yield sendAndConfirmTransaction(tx, connection, Object.assign({ skipPreflight: false }, options === null || options === void 0 ? void 0 : options.sendOptions), options === null || options === void 0 ? void 0 : options.serializeConfig);
        if (signatureResult.err !== null) {
            if (!(options === null || options === void 0 ? void 0 : options.suppressLogging)) {
                console.error('Transaction signature: ', signature);
                const transaction = yield connection.getTransaction(signature, {
                    commitment,
                    maxSupportedTransactionVersion: 1,
                });
                console.error('Transaction logs: ', (_a = transaction === null || transaction === void 0 ? void 0 : transaction.meta) === null || _a === void 0 ? void 0 : _a.logMessages);
                console.error(`Explorer link: ${formatExplorerLink(signature, connection)}`);
            }
            throw new Error('Transaction error: ' + JSON.stringify(signatureResult.err, null, 2));
        }
        else if (options != undefined &&
            options.suppressLogging != undefined &&
            !options.suppressLogging) {
            // Please don't delete this xD. Is for the case we want to print the logs even if the IX success
            console.info('Transaction signature: ', signature);
            const transaction = yield connection.getTransaction(signature, {
                commitment,
                maxSupportedTransactionVersion: 1,
            });
            // transaction?.transaction.message.getAccountKeys();
            console.info('Transaction logs: ', (_b = transaction === null || transaction === void 0 ? void 0 : transaction.meta) === null || _b === void 0 ? void 0 : _b.logMessages);
        }
        return signature;
    });
}
exports.buildSendAndCheck = buildSendAndCheck;
function prettyTransaction(tx, accountKeyArgs) {
    var _a;
    if (isVersionedTransaction(tx)) {
        const accountKeys = tx.message.getAccountKeys(accountKeyArgs);
        return {
            signatures: prettySignature(tx.signatures, accountKeys),
            instructions: prettyInstructions(tx.message, accountKeys),
            feePayer: tx.message.staticAccountKeys[0].toBase58(),
            recentBlockhash: tx.message.recentBlockhash,
        };
    }
    else {
        return {
            signatures: tx.signatures.map((sig) => ({
                publicKey: sig.publicKey.toBase58(),
                signature: sig.signature !== null,
            })),
            instructions: tx.instructions.map((ix) => ({
                keys: ix.keys.map((meta) => (Object.assign(Object.assign({}, meta), { pubkey: meta.pubkey.toBase58() }))),
                programId: ix.programId.toBase58(),
            })),
            feePayer: (_a = tx.feePayer) === null || _a === void 0 ? void 0 : _a.toBase58(),
            recentBlockhash: tx.recentBlockhash,
        };
    }
}
exports.prettyTransaction = prettyTransaction;
function prettySignature(signatures, accountKeys) {
    return signatures.map((sig, index) => {
        var _a;
        return ({
            publicKey: (_a = accountKeys.get(index)) === null || _a === void 0 ? void 0 : _a.toBase58(),
            signature: sig.every((byte) => byte !== 0),
        });
    });
}
function prettyInstructions(message, accountKeys) {
    return message.compiledInstructions.map((ix) => {
        var _a;
        return ({
            keys: ix.accountKeyIndexes.map((keyIndex) => {
                const key = accountKeys.get(keyIndex);
                return {
                    pubkey: key === null || key === void 0 ? void 0 : key.toBase58(),
                    isSigner: message.isAccountSigner(keyIndex),
                    isWritable: message.isAccountWritable(keyIndex),
                };
            }),
            programId: (_a = accountKeys.get(ix.programIdIndex)) === null || _a === void 0 ? void 0 : _a.toBase58(),
        });
    });
}
//# sourceMappingURL=transactionHandling.js.map