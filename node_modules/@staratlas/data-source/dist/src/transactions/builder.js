"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = exports.transactionReturnIterator = exports.TransactionBuilderCore = exports.checkTraceExceeded = void 0;
const web3_js_1 = require("@solana/web3.js");
const neverthrow_1 = require("neverthrow");
const util_1 = require("../util");
const compute_1 = require("./compute");
const sizing_1 = require("./sizing");
const transactionHandling_1 = require("./transactionHandling");
function checkTraceExceeded(simulation) {
    const error = simulation.value.err;
    if (error) {
        if (typeof error == 'object' && 'InstructionError' in error) {
            const ixError = error.InstructionError;
            if (ixError && typeof ixError === 'object') {
                const isTrace = '1' in ixError &&
                    typeof ixError[1] === 'string' &&
                    ixError[1] === 'MaxInstructionTraceLengthExceeded';
                if (isTrace && '0' in ixError) {
                    if (typeof ixError[0] === 'number') {
                        const ixTraces = [];
                        // const logs = simulation.value.logs;
                        // if (logs) {
                        //   for (const log of logs) {
                        //     if (log.startsWith('Program log:')) {
                        //       const split = log.split(' ');
                        //       const ix = split[2];
                        //       if (ix) {
                        //         ixTraces.push(Number(ix));
                        //       }
                        //     }
                        //   }
                        // }
                        return {
                            traceExceeded: ixError[0],
                            unitsConsumed: simulation.value.unitsConsumed,
                            // todo: parse logs to get the ix trace count for each instruction
                            ixTraces,
                        };
                    }
                }
            }
        }
    }
}
exports.checkTraceExceeded = checkTraceExceeded;
class TransactionBuilderCore {
    constructor(args) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.instructions = [];
        this.lastBuilt = null;
        this.lastTransaction = null;
        this.lastTryIterations = 0;
        this.isBuildingNext = false;
        this.connection = args.connection;
        this.commitment =
            (_b = (_a = args.commitment) !== null && _a !== void 0 ? _a : args.connection.commitment) !== null && _b !== void 0 ? _b : 'confirmed';
        this.feePayer = args.feePayer;
        this.lookupTables = (_c = args.lookupTables) !== null && _c !== void 0 ? _c : [];
        this.beforeIxs = (_d = args.beforeIxs) !== null && _d !== void 0 ? _d : [];
        this.afterIxs = (_e = args.afterIxs) !== null && _e !== void 0 ? _e : [];
        this.instructionCountConfig = {
            max: (_f = args.instructionCount) === null || _f === void 0 ? void 0 : _f.max,
            maxOnFail: (_g = args.instructionCount) === null || _g === void 0 ? void 0 : _g.maxOnFail,
        };
        const defaultLimit = (num) => {
            return num + Math.min(100000, Math.max(10000, num * 0.1));
        };
        this.mapLimit = args.mapLimit || defaultLimit;
        this.getFee = args.getFee;
    }
    add(instruction, signers) {
        const instructions = (0, util_1.normalizeArray)(instruction);
        if (instructions.length === 0) {
            return this;
        }
        if (typeof instructions[0] === 'function') {
            this.instructions.push(...instructions);
        }
        else {
            this.instructions.push(...instructions.map((ix) => {
                let actualSigners = undefined;
                if (signers) {
                    const signersKeys = ix.keys
                        .filter((k) => k.isSigner)
                        .map((k) => k.pubkey);
                    actualSigners = signers.filter((s) => signersKeys.some((k) => k.equals(s.publicKey())));
                }
                return (0, transactionHandling_1.ixToIxReturn)(ix, actualSigners);
            }));
        }
        return this;
    }
    getPopCount(buildConfig) {
        return (buildConfig.instructions.length -
            buildConfig.computeCount -
            buildConfig.beforeCount -
            buildConfig.afterCount);
    }
    resetIterations() {
        this.lastTryIterations = 0;
    }
    computeBeforeIxs() {
        return [...compute_1.COMPUTE_TEST_INSTRUCTION_RETURNS, ...this.beforeIxs];
    }
    resetDummyComputeInstructions(builtConfig) {
        builtConfig.instructions.splice(0, builtConfig.computeCount);
        builtConfig.computeCount = 2;
        builtConfig.instructions.unshift(...compute_1.COMPUTE_TEST_INSTRUCTIONS.map((ix) => {
            return {
                instruction: ix,
                signers: [],
            };
        }));
    }
    getLatestBlockhash() {
        return this.connection.getLatestBlockhash({ commitment: this.commitment });
    }
    parseSimulationResult(simulation) {
        var _a;
        const error = simulation.value.err;
        if (!error) {
            return (0, neverthrow_1.ok)((_a = simulation.value) === null || _a === void 0 ? void 0 : _a.unitsConsumed);
        }
        const maybeTrace = checkTraceExceeded(simulation);
        if (maybeTrace) {
            return (0, neverthrow_1.err)(maybeTrace);
        }
        return (0, neverthrow_1.err)(undefined);
    }
    simulateTransaction(txn) {
        return __awaiter(this, void 0, void 0, function* () {
            const commitment = this.commitment === 'processed' ? 'processed' : 'confirmed';
            const simulation = yield this.connection.simulateTransaction(txn, {
                commitment,
                replaceRecentBlockhash: true,
            });
            return this.parseSimulationResult(simulation);
        });
    }
    handlePriorityOptimization(buildConfig, ignoreError, depth, maxDepth = 3) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (depth > maxDepth) {
                return (0, neverthrow_1.err)('Priority optimizer depth exceeded');
            }
            const txn = (0, compute_1.buildSimulationTransaction)(buildConfig.instructions.map((i) => i.instruction), buildConfig.lookupTables, this.feePayer.publicKey());
            const writableKeys = (0, compute_1.getWritableAccounts)(buildConfig.instructions.map((i) => i.instruction));
            this.lastTryIterations++;
            const [simulation, fee] = yield Promise.all([
                this.simulateTransaction(txn),
                this.getFee
                    ? yield this.getFee(writableKeys, this.connection)
                    : undefined,
            ]);
            let limit = undefined;
            if (simulation.isOk()) {
                const units = simulation.value;
                if (units !== undefined) {
                    limit = this.mapLimit(units);
                }
            }
            else if (typeof simulation.error === 'string') {
                return (0, neverthrow_1.err)(simulation.error);
            }
            else if (!ignoreError) {
                const error = simulation.error;
                let doMaxOnFail = false;
                if (typeof error === 'string') {
                    return (0, neverthrow_1.err)(error);
                }
                else if (error !== undefined) {
                    const { traceExceeded, ixTraces, unitsConsumed } = error;
                    if (buildConfig.afterCount === 0) {
                        buildConfig.instructions.splice(traceExceeded - 1);
                        return this.handlePriorityOptimization(buildConfig, true, depth + 1);
                    }
                    else {
                        // todo: once 1.18 comes around, utilize innerInstructions from simulation
                        doMaxOnFail = true;
                    }
                }
                else {
                    doMaxOnFail = true;
                }
                if (doMaxOnFail) {
                    const maxOnFail = (_a = this.instructionCountConfig.maxOnFail) !== null && _a !== void 0 ? _a : 14;
                    if (buildConfig.instructions.length <= maxOnFail) {
                        console.warn('TransactionBuilder: simulation failed; instructions count is less than max on fail. Ignoring error...');
                    }
                    else {
                        const maxRemovable = this.getPopCount(buildConfig);
                        let removeCount = buildConfig.instructions.length - maxOnFail;
                        if (removeCount > maxRemovable) {
                            console.warn(`TransactionBuilder: simulation failed; remove count is greater than max removable of ${maxRemovable}. Removing ${maxRemovable - 1} instructions`);
                            removeCount = maxRemovable - 1;
                        }
                        buildConfig.instructions.splice(buildConfig.beforeCount + buildConfig.computeCount, removeCount);
                        return this.handlePriorityOptimization(buildConfig, true, depth + 1);
                    }
                }
            }
            return (0, neverthrow_1.ok)({ limit, fee });
        });
    }
    replaceComputeInstructions(builtConfig, priorityResult) {
        const { limit, fee } = priorityResult;
        // remove dummy compute instructions
        builtConfig.instructions.splice(0, builtConfig.computeCount);
        builtConfig.computeCount = 0;
        if (limit !== undefined) {
            builtConfig.instructions.unshift({
                instruction: web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                    units: limit,
                }),
                signers: [],
            });
            builtConfig.computeCount++;
        }
        if (fee !== undefined) {
            builtConfig.instructions.unshift({
                instruction: web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                    microLamports: fee,
                }),
                signers: [],
            });
            builtConfig.computeCount++;
        }
    }
    startBuildingNext() {
        if (this.isBuildingNext) {
            throw new Error('Already building next optimal transaction');
        }
        this.isBuildingNext = true;
    }
    // todo: figure out a better error type for this. String doesnt cut it
    buildNextOptimalTransactionNoSigning() {
        return __awaiter(this, void 0, void 0, function* () {
            this.resetIterations();
            const beforeIxs = this.computeBeforeIxs();
            const next = yield (0, sizing_1.getNextFullTransaction)(this.instructions, this.feePayer, beforeIxs, this.afterIxs.map((ix) => ix.ix), this.lookupTables, this.instructionCountConfig.max);
            if (next.isErr()) {
                return (0, neverthrow_1.err)(next.error);
            }
            const [ixs] = next.value;
            const buildConfig = Object.assign(Object.assign({}, ixs), { computeCount: compute_1.COMPUTE_TEST_INSTRUCTION_RETURNS.length, beforeCount: this.beforeIxs.length, afterCount: this.afterIxs.length });
            const [priorityResult, rbh] = yield Promise.all([
                this.handlePriorityOptimization(buildConfig, false, 0),
                this.getLatestBlockhash(),
            ]);
            if (priorityResult.isErr()) {
                return (0, neverthrow_1.err)(priorityResult.error);
            }
            const { fee, limit } = priorityResult.value;
            this.replaceComputeInstructions(buildConfig, { limit, fee });
            const lastBuilt = Object.assign(Object.assign({}, buildConfig), (0, sizing_1.deepCopyInstructions)(buildConfig));
            return (0, neverthrow_1.ok)({
                // ixs,
                rbh,
                lastBuilt,
            });
        });
    }
    rebuildLastNoSigning(recalculatePriority) {
        return __awaiter(this, void 0, void 0, function* () {
            this.resetIterations();
            if (this.lastBuilt === null) {
                return (0, neverthrow_1.err)('No last built transaction to rebuild');
            }
            const lastBuiltCopy = Object.assign(Object.assign({}, this.lastBuilt), (0, sizing_1.deepCopyInstructions)(this.lastBuilt));
            let rbh;
            if (recalculatePriority) {
                this.resetDummyComputeInstructions(lastBuiltCopy);
                const oldPopCount = this.getPopCount(lastBuiltCopy);
                const [priorityRes, recentBlockhash] = yield Promise.all([
                    this.handlePriorityOptimization(lastBuiltCopy, false, 0, 1),
                    this.getLatestBlockhash(),
                ]);
                rbh = recentBlockhash;
                if (priorityRes.isErr()) {
                    return (0, neverthrow_1.err)(priorityRes.error);
                }
                const { fee, limit } = priorityRes.value;
                const newPopCount = this.getPopCount(lastBuiltCopy);
                if (newPopCount !== oldPopCount) {
                    console.warn(`TransactionBuilder: pop count changed from ${oldPopCount} to ${newPopCount} in rebuildLastBuilt`);
                }
                this.replaceComputeInstructions(lastBuiltCopy, { limit, fee });
            }
            else {
                rbh = yield this.getLatestBlockhash();
            }
            return (0, neverthrow_1.ok)({
                lastBuilt: lastBuiltCopy,
                rbh,
            });
        });
    }
    handlePostBuild(txReturn, lastBuilt) {
        const popCount = this.getPopCount(lastBuilt);
        if (popCount <= 0) {
            throw new Error('TransactionBuilder: pop count is less than or equal to 0');
        }
        this.instructions.splice(0, this.getPopCount(lastBuilt));
        this.lastBuilt = lastBuilt;
        this.lastTransaction = txReturn;
    }
    clear() {
        return this.instructions.splice(0, this.instructions.length);
    }
}
exports.TransactionBuilderCore = TransactionBuilderCore;
function transactionReturnIterator(transactions) {
    return __asyncGenerator(this, arguments, function* transactionReturnIterator_1() {
        if (transactions.isErr()) {
            yield yield __await((0, neverthrow_1.err)(transactions.error));
        }
        else {
            for (const transaction of transactions.value) {
                yield yield __await((0, neverthrow_1.ok)(transaction));
            }
        }
    });
}
exports.transactionReturnIterator = transactionReturnIterator;
class TransactionBuilder extends TransactionBuilderCore {
    constructor(args) {
        super(args);
    }
    optimalTransactions() {
        return __asyncGenerator(this, arguments, function* optimalTransactions_1() {
            while (this.instructions.length > 0) {
                yield yield __await(this.buildNextOptimalTransaction());
            }
        });
    }
    buildNextOptimalTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            this.startBuildingNext();
            try {
                const res = yield this.buildNextOptimalTransactionNoSigning();
                if (res.isErr()) {
                    return (0, neverthrow_1.err)(res.error);
                }
                const { rbh, lastBuilt } = res.value;
                const toReturn = (yield (0, transactionHandling_1.buildAndSignTransactionsFromIxWithSigners)([
                    {
                        ixs: lastBuilt.instructions,
                        lookupTables: lastBuilt.lookupTables,
                        connectionOrRbh: {
                            rbh,
                            commitment: this.commitment,
                        },
                    },
                ], this.feePayer))[0];
                this.handlePostBuild(toReturn, lastBuilt);
                return (0, neverthrow_1.ok)(toReturn);
            }
            finally {
                this.isBuildingNext = false;
            }
        });
    }
    rebuildLast(recalculatePriority = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.rebuildLastNoSigning(recalculatePriority);
            if (res.isErr()) {
                return (0, neverthrow_1.err)(res.error);
            }
            const { lastBuilt, rbh } = res.value;
            const toReturn = (yield (0, transactionHandling_1.buildAndSignTransactionsFromIxWithSigners)([
                {
                    ixs: lastBuilt.instructions,
                    lookupTables: lastBuilt.lookupTables,
                    connectionOrRbh: {
                        rbh,
                        commitment: this.commitment,
                    },
                },
            ], this.feePayer))[0];
            return (0, neverthrow_1.ok)(toReturn);
        });
    }
    buildDynamic() {
        return (0, compute_1.buildOptimalDynamicTransactions)(this.connection, this.instructions, this.feePayer, {
            getFee: this.getFee,
            getLimit: (...args) => (0, compute_1.getSimulationUnits)(...args).then((units) => {
                if (units !== undefined) {
                    return this.mapLimit(units);
                }
            }),
        }, this.lookupTables, this.beforeIxs, this.afterIxs.map((ix) => ix.ix), this.instructionCountConfig.max);
    }
    buildAndSignOptimal() {
        var _a;
        const instructions = [
            ...this.beforeIxs,
            ...this.instructions,
            ...this.afterIxs.map((ix) => ix.ix),
        ];
        const priorityConfig = {
            getLimit: (...args) => (0, compute_1.getSimulationUnits)(...args).then((units) => {
                if (units !== undefined) {
                    return this.mapLimit(units);
                }
            }),
            getFee: (_a = this.getFee) !== null && _a !== void 0 ? _a : undefined,
        };
        return (0, compute_1.buildAndSignOptimalTransaction)(this.connection, instructions, this.feePayer, priorityConfig, this.lookupTables);
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=builder.js.map