import { AddressLookupTableAccount, Connection, PublicKey, TransactionInstruction, VersionedTransaction } from '@solana/web3.js';
import { Result } from 'neverthrow';
import { AsyncSigner } from '../asyncSigner';
import { BuildTransactionsType, InstructionReturn, TransactionReturn } from './transactionHandling';
export declare const COMPUTE_TEST_INSTRUCTION_RETURNS: InstructionReturn[];
export declare const COMPUTE_TEST_INSTRUCTIONS: TransactionInstruction[];
export declare function getWritableAccounts(instructions: TransactionInstruction[]): PublicKey[];
export declare function buildSimulationTransaction(instructions: TransactionInstruction[], lookupTables: AddressLookupTableAccount[], payerKey: PublicKey): VersionedTransaction;
/**
 * Gets the compute units used in a transaction by simulating it.
 * @param transaction - The transaction to simulate.
 * @param connection - The connection to use for the simulation.
 * @returns The number of compute units used in the simulation, or undefined if the simulation failed.
 */
export declare const getSimulationUnits: GetComputeLimit;
export type GetPriorityFee = (writableAccounts: PublicKey[], connection: Connection) => Promise<number>;
export type GetComputeLimit = (transaction: VersionedTransaction, connection: Connection) => Promise<number | undefined>;
export type PriorityConfig = {
    getLimit: GetComputeLimit | undefined;
    getFee: GetPriorityFee | undefined;
};
/**
 * Builds a compute-optimized transaction from a set of instructions, fee payer, connection, and lookup tables
 *
 * @param connection - The connection to use for getting the rbh and passed in to the priority config functions
 * @param instructions - The main instructions to include in the transaction.
 * @param feePayer - The fee payer for the transaction.
 * @param priorityConfig - Configuration for if and how the Compute budget instructions will be added to the transaction.
 * @param lookupTables - Optional list of lookup tables to try to build transaction with.
 * @returns A promise that resolves to a Transaction with rbh and commitment.
 */
export declare function buildAndSignOptimalTransaction(connection: Connection, instructions: InstructionReturn | InstructionReturn[], feePayer: AsyncSigner, priorityConfig: PriorityConfig, lookupTables?: AddressLookupTableAccount[]): Promise<TransactionReturn>;
/**
 * @deprecated
 * Builds compute-optimized dynamic transactions from a set of instructions, fee payer, connection, lookup tables, and optional before/after instructions.
 * This should only be run with instructions that can be executed in parallel. If the instructions are dependent on each other, subsequent simulations will fail and the compute limit numbers will be incorrect.s
 *
 * @param connection - The connection to use for getting the rbh and passed in to the priority config functions
 * @param instructions - The main instructions to include in the transactions.
 * @param feePayer - The fee payer for the transactions.
 * @param priorityConfig - Configuration for if and how the Compute budget instructions will be added to the transactions.
 * @param lookupTables - Optional list of lookup tables to try to build transactions with.
 * @param beforeIxs - Optional instructions to include at the beginning of each transaction.
 * @param afterIxs - Optional instructions to include at the end of each transaction.
 * @param maxInstructionCount - The maximum number of instructions to include in each transaction.
 * @returns A promise that resolves to a result object containing either the built transactions or an error message.
 */
export declare function buildOptimalDynamicTransactions(connection: Connection, instructions: InstructionReturn | InstructionReturn[], feePayer: AsyncSigner, priorityConfig: PriorityConfig, lookupTables?: AddressLookupTableAccount[], beforeIxs?: InstructionReturn[], afterIxs?: InstructionReturn[], maxInstructionCount?: number): Promise<Result<TransactionReturn[], string>>;
/**
 * Builds compute-optimized `BuildTransactionsType` from a set of instructions, fee payer, connection, lookup tables, and optional before/after instructions.
 * This should only be run with instructions that can be executed in parallel. If the instructions are dependent on each other, subsequent simulations will fail and the compute limit numbers will be incorrect.s
 *
 * @param connection - The connection to use for getting the rbh and passed in to the priority config functions
 * @param instructions - The main instructions to include in the transactions.
 * @param feePayer - The fee payer for the transactions.
 * @param priorityConfig - Configuration for if and how the Compute budget instructions will be added to the transactions.
 * @param lookupTables - Optional list of lookup tables to try to build transactions with.
 * @param beforeIxs - Optional instructions to include at the beginning of each transaction.
 * @param afterIxs - Optional instructions to include at the end of each transaction.
 * @param maxInstructionCount - The maximum number of instructions to include in each transaction.
 * @returns A promise that resolves to the `BuildTransactionsType`, which can be converted to transaction returns using `buildAndSignTransactionsFromIxWithSigners`.
 */
export declare function buildOptimalDynamicTransactionsNoSigning(connection: Connection, instructions: InstructionReturn | InstructionReturn[], feePayer: AsyncSigner, priorityConfig: PriorityConfig, lookupTables?: AddressLookupTableAccount[], beforeIxs?: InstructionReturn[], afterIxs?: InstructionReturn[], maxInstructionCount?: number): Promise<BuildTransactionsType[]>;
//# sourceMappingURL=compute.d.ts.map