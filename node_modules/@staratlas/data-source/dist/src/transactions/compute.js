"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildOptimalDynamicTransactionsNoSigning = exports.buildOptimalDynamicTransactions = exports.buildAndSignOptimalTransaction = exports.getSimulationUnits = exports.buildSimulationTransaction = exports.getWritableAccounts = exports.COMPUTE_TEST_INSTRUCTIONS = exports.COMPUTE_TEST_INSTRUCTION_RETURNS = void 0;
const web3_js_1 = require("@solana/web3.js");
const neverthrow_1 = require("neverthrow");
const util_1 = require("../util");
const sizing_1 = require("./sizing");
const transactionHandling_1 = require("./transactionHandling");
exports.COMPUTE_TEST_INSTRUCTION_RETURNS = [
    (0, transactionHandling_1.ixToIxReturn)(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 426 })),
    (0, transactionHandling_1.ixToIxReturn)(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: 1400000 })),
];
exports.COMPUTE_TEST_INSTRUCTIONS = [
    web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 426 }),
    web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units: 1400000 }),
];
function getWritableAccounts(instructions) {
    const keys = instructions
        .map((ix) => ix.keys.filter((meta) => meta.isWritable).map((meta) => meta.pubkey))
        .flat();
    const uniqueKeys = new Set(keys);
    return Array.from(uniqueKeys);
}
exports.getWritableAccounts = getWritableAccounts;
function buildSimulationTransaction(instructions, lookupTables, payerKey) {
    return new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
        instructions,
        payerKey,
        recentBlockhash: web3_js_1.PublicKey.default.toString(),
    }).compileToV0Message(lookupTables));
}
exports.buildSimulationTransaction = buildSimulationTransaction;
/**
 * Gets the compute units used in a transaction by simulating it.
 * @param transaction - The transaction to simulate.
 * @param connection - The connection to use for the simulation.
 * @returns The number of compute units used in the simulation, or undefined if the simulation failed.
 */
const getSimulationUnits = (transaction, connection) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const simulation = yield connection.simulateTransaction(transaction, {
        sigVerify: false,
        replaceRecentBlockhash: true,
    });
    if (simulation.value.err) {
        return undefined;
    }
    return (_a = simulation.value) === null || _a === void 0 ? void 0 : _a.unitsConsumed;
});
exports.getSimulationUnits = getSimulationUnits;
/**
 * Builds a compute-optimized transaction from a set of instructions, fee payer, connection, and lookup tables
 *
 * @param connection - The connection to use for getting the rbh and passed in to the priority config functions
 * @param instructions - The main instructions to include in the transaction.
 * @param feePayer - The fee payer for the transaction.
 * @param priorityConfig - Configuration for if and how the Compute budget instructions will be added to the transaction.
 * @param lookupTables - Optional list of lookup tables to try to build transaction with.
 * @returns A promise that resolves to a Transaction with rbh and commitment.
 */
function buildAndSignOptimalTransaction(connection, instructions, feePayer, priorityConfig, lookupTables = []) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const ixArray = (0, util_1.normalizeArray)(instructions);
        const getLimit = () => __awaiter(this, void 0, void 0, function* () {
            if (priorityConfig.getLimit === undefined) {
                return undefined;
            }
            const simulationTransaction = buildSimulationTransaction([
                ...exports.COMPUTE_TEST_INSTRUCTIONS,
                ...(yield (0, transactionHandling_1.ixReturnsToIxs)(ixArray, feePayer)),
            ], lookupTables, feePayer.publicKey());
            return priorityConfig.getLimit(simulationTransaction, connection);
        });
        const getFee = () => __awaiter(this, void 0, void 0, function* () {
            if (priorityConfig.getFee === undefined) {
                return undefined;
            }
            const txInstructions = yield (0, transactionHandling_1.ixReturnsToIxs)(ixArray, feePayer);
            const writableKeys = getWritableAccounts(txInstructions);
            return priorityConfig.getFee(writableKeys, connection);
        });
        const [units, microLamports, rbh] = yield Promise.all([
            getLimit(),
            getFee(),
            connection.getLatestBlockhash(),
        ]);
        if (units) {
            ixArray.unshift((0, transactionHandling_1.ixToIxReturn)(web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({ units })));
        }
        if (microLamports) {
            ixArray.unshift((0, transactionHandling_1.ixToIxReturn)(web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({ microLamports })));
        }
        return (0, transactionHandling_1.buildAndSignTransaction)(ixArray, feePayer, { rbh, commitment: (_a = connection.commitment) !== null && _a !== void 0 ? _a : 'confirmed' }, lookupTables);
    });
}
exports.buildAndSignOptimalTransaction = buildAndSignOptimalTransaction;
/**
 * @deprecated
 * Builds compute-optimized dynamic transactions from a set of instructions, fee payer, connection, lookup tables, and optional before/after instructions.
 * This should only be run with instructions that can be executed in parallel. If the instructions are dependent on each other, subsequent simulations will fail and the compute limit numbers will be incorrect.s
 *
 * @param connection - The connection to use for getting the rbh and passed in to the priority config functions
 * @param instructions - The main instructions to include in the transactions.
 * @param feePayer - The fee payer for the transactions.
 * @param priorityConfig - Configuration for if and how the Compute budget instructions will be added to the transactions.
 * @param lookupTables - Optional list of lookup tables to try to build transactions with.
 * @param beforeIxs - Optional instructions to include at the beginning of each transaction.
 * @param afterIxs - Optional instructions to include at the end of each transaction.
 * @param maxInstructionCount - The maximum number of instructions to include in each transaction.
 * @returns A promise that resolves to a result object containing either the built transactions or an error message.
 */
function buildOptimalDynamicTransactions(connection, instructions, feePayer, priorityConfig, lookupTables = [], beforeIxs, afterIxs, maxInstructionCount = 64) {
    return __awaiter(this, void 0, void 0, function* () {
        const [buildTransactions, rbh] = yield Promise.all([
            buildOptimalDynamicTransactionsNoSigning(connection, instructions, feePayer, priorityConfig, lookupTables, beforeIxs, afterIxs, maxInstructionCount),
            connection.getLatestBlockhash(),
        ]);
        buildTransactions.forEach((build) => {
            var _a;
            build.connectionOrRbh = {
                rbh,
                commitment: (_a = connection.commitment) !== null && _a !== void 0 ? _a : 'confirmed',
            };
        });
        return (0, neverthrow_1.ok)(yield (0, transactionHandling_1.buildAndSignTransactionsFromIxWithSigners)(buildTransactions, feePayer));
    });
}
exports.buildOptimalDynamicTransactions = buildOptimalDynamicTransactions;
/**
 * Builds compute-optimized `BuildTransactionsType` from a set of instructions, fee payer, connection, lookup tables, and optional before/after instructions.
 * This should only be run with instructions that can be executed in parallel. If the instructions are dependent on each other, subsequent simulations will fail and the compute limit numbers will be incorrect.s
 *
 * @param connection - The connection to use for getting the rbh and passed in to the priority config functions
 * @param instructions - The main instructions to include in the transactions.
 * @param feePayer - The fee payer for the transactions.
 * @param priorityConfig - Configuration for if and how the Compute budget instructions will be added to the transactions.
 * @param lookupTables - Optional list of lookup tables to try to build transactions with.
 * @param beforeIxs - Optional instructions to include at the beginning of each transaction.
 * @param afterIxs - Optional instructions to include at the end of each transaction.
 * @param maxInstructionCount - The maximum number of instructions to include in each transaction.
 * @returns A promise that resolves to the `BuildTransactionsType`, which can be converted to transaction returns using `buildAndSignTransactionsFromIxWithSigners`.
 */
function buildOptimalDynamicTransactionsNoSigning(connection, instructions, feePayer, priorityConfig, lookupTables = [], beforeIxs, afterIxs, maxInstructionCount = 64) {
    return __awaiter(this, void 0, void 0, function* () {
        const testBeforeIxs = [
            ...exports.COMPUTE_TEST_INSTRUCTION_RETURNS,
            ...(beforeIxs !== null && beforeIxs !== void 0 ? beforeIxs : []),
        ];
        const noSigning = yield (0, sizing_1.buildDynamicTransactionsNoSigning)(instructions, feePayer, testBeforeIxs, afterIxs, lookupTables, maxInstructionCount);
        if (noSigning.isErr()) {
            throw noSigning.error;
        }
        const noSignedIxs = noSigning.value.map((v) => {
            const testInstructions = v.instructions.map((i) => i.instruction);
            const writableKeys = priorityConfig.getFee
                ? getWritableAccounts(testInstructions)
                : [];
            const simulationTransaction = buildSimulationTransaction(testInstructions, v.lookupTables, feePayer.publicKey());
            // remove the temp compute budget instructions
            v.instructions.splice(0, 2);
            return {
                simulationTransaction,
                writableKeys,
                instructionsWithSigners: v,
            };
        });
        const getIxWithComputeBudget = () => Promise.all(noSignedIxs.map(({ writableKeys, simulationTransaction, instructionsWithSigners, }) => __awaiter(this, void 0, void 0, function* () {
            const [simulationUnits, fees] = yield Promise.all([
                priorityConfig.getLimit
                    ? priorityConfig.getLimit(simulationTransaction, connection)
                    : undefined,
                priorityConfig.getFee
                    ? priorityConfig.getFee(writableKeys, connection)
                    : undefined,
            ]);
            return { simulationUnits, fees, instructionsWithSigners };
        })));
        const ixWithComputeBudget = yield getIxWithComputeBudget();
        return ixWithComputeBudget.map((ix) => {
            const ixWithSigners = ix.instructionsWithSigners;
            if (ix.fees !== undefined) {
                ixWithSigners.instructions.unshift({
                    instruction: web3_js_1.ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: ix.fees,
                    }),
                    signers: [],
                });
            }
            if (ix.simulationUnits !== undefined) {
                ixWithSigners.instructions.unshift({
                    instruction: web3_js_1.ComputeBudgetProgram.setComputeUnitLimit({
                        units: ix.simulationUnits,
                    }),
                    signers: [],
                });
            }
            return {
                connectionOrRbh: {
                    connection,
                },
                ixs: ixWithSigners.instructions,
                lookupTables: ixWithSigners.lookupTables,
            };
        });
    });
}
exports.buildOptimalDynamicTransactionsNoSigning = buildOptimalDynamicTransactionsNoSigning;
//# sourceMappingURL=compute.js.map