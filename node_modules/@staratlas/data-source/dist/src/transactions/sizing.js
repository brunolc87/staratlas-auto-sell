"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDynamicTransactions = exports.buildDynamicTransactionsNoSigning = exports.getNextFullTransaction = exports.buildLookupTableSet = exports.deepCopyInstructions = exports.insert = exports.getTransactionSize = exports.containedInLUTCount = exports.MAX_UNIQUE_KEYS_COUNT = exports.MAX_TRANSACTION_SIZE = void 0;
const web3_js_1 = require("@solana/web3.js");
const neverthrow_1 = require("neverthrow");
const util_1 = require("../util");
const transactionHandling_1 = require("./transactionHandling");
exports.MAX_TRANSACTION_SIZE = 1232;
exports.MAX_UNIQUE_KEYS_COUNT = 128;
/*
  Returns the number of keys in the set that are contained in the lookup table, along with a set of the remaining keys that aren't
 */
function containedInLUTCount(keys, lookupTableAddresses) {
    let includedCount = 0;
    const notIncluded = new Set();
    keys.forEach((k) => {
        if (lookupTableAddresses.has(k)) {
            includedCount++;
        }
        else {
            notIncluded.add(k);
        }
    });
    return [includedCount, notIncluded];
}
exports.containedInLUTCount = containedInLUTCount;
function getTransactionSize(instructions, funder, lookupTables = []) {
    const uniqueSigners = new Set();
    const programIds = new Set();
    const lutEligibleKeys = new Set();
    uniqueSigners.add(funder.toBase58());
    instructions.forEach(({ instruction }) => {
        programIds.add(instruction.programId.toBase58());
        instruction.keys.forEach((s) => {
            if (s.isSigner) {
                uniqueSigners.add(s.pubkey.toBase58());
            }
            lutEligibleKeys.add(s.pubkey.toBase58());
        });
    });
    // remove signers and top level program ids from lut eligible keys
    for (const signer of uniqueSigners) {
        lutEligibleKeys.delete(signer);
    }
    for (const programId of programIds) {
        lutEligibleKeys.delete(programId);
    }
    // shouldn't be possible for a program id to be a signer, but just in case...
    const ineligibleKeys = new Set([...uniqueSigners, ...programIds]);
    let ixSizes = 0;
    instructions.forEach(({ instruction }) => {
        ixSizes +=
            1 + // program id index
                lengthToCompact16size(instruction.keys.length) + // num accounts
                instruction.keys.length + // account indexes
                lengthToCompact16size(instruction.data.length) + // num ix bytes
                instruction.data.length; // ix bytes
    });
    const staticSize = lengthToCompact16size(uniqueSigners.size) + // num sigs
        uniqueSigners.size * 64 + // Sigs
        3 + // message header
        32 + // recent blockhash
        1 + // version field, assume all are v0
        lengthToCompact16size(instructions.length) + // num instructions
        ixSizes +
        1; // LUT length field
    const staticAccountSize = {
        staticSize,
        staticAccounts: ineligibleKeys.size,
    };
    const bestSize = totalSize(staticAccountSize, 0, 0, lutEligibleKeys.size);
    const uniqueKeyCount = ineligibleKeys.size + lutEligibleKeys.size;
    if (bestSize <= exports.MAX_TRANSACTION_SIZE || lookupTables.length === 0) {
        return {
            size: bestSize,
            lookupTables: [],
            uniqueKeyCount,
        };
    }
    else if (uniqueKeyCount > exports.MAX_UNIQUE_KEYS_COUNT) {
        return {
            size: bestSize,
            lookupTables: [],
            uniqueKeyCount,
        };
    }
    return findBestLookupTables(staticAccountSize, bestSize, 0, 0, lutEligibleKeys, [], [...lookupTables]);
}
exports.getTransactionSize = getTransactionSize;
function findBestLookupTables(staticAccountSize, size, lutCount, includedAccounts, remainingAccounts, usedLuts, remainingLuts) {
    if (remainingLuts.length === 0) {
        return {
            size,
            lookupTables: usedLuts,
            uniqueKeyCount: includedAccounts + remainingAccounts.size,
        };
    }
    let bestRemaining = remainingAccounts;
    let bestSize = size;
    let bestIncluded = includedAccounts;
    let bestLutIndex = 0;
    for (const [lutIndex, lut] of remainingLuts.entries()) {
        const [count, remainingUnique] = containedInLUTCount(remainingAccounts, lut[0]);
        const newIncluded = includedAccounts + count;
        const txnSize = totalSize(staticAccountSize, lutCount + 1, newIncluded, remainingUnique.size);
        if (txnSize < exports.MAX_TRANSACTION_SIZE) {
            usedLuts.push(lut[1]);
            return {
                size: txnSize,
                lookupTables: usedLuts,
                uniqueKeyCount: newIncluded + remainingUnique.size,
            };
        }
        else if (txnSize < bestSize) {
            bestSize = txnSize;
            bestRemaining = remainingUnique;
            bestIncluded = newIncluded;
            bestLutIndex = lutIndex;
        }
    }
    if (size === bestSize) {
        return {
            size: size,
            lookupTables: usedLuts,
            uniqueKeyCount: includedAccounts + remainingAccounts.size,
        };
    }
    // remove the best lut from the remaining luts and add it to the used luts
    const bestLut = remainingLuts.splice(bestLutIndex, 1)[0];
    usedLuts.push(bestLut[1]);
    return findBestLookupTables(staticAccountSize, bestSize, lutCount + 1, bestIncluded, bestRemaining, usedLuts, remainingLuts);
}
/**
 * Returns the total size of a serialized transaction
 * @param staticAccountSize - the static size and number of static accounts in a transaction
 * @param lutCount - the number of LUTs that are in a transaction
 * @param includedAccounts - the number of accounts that are in a LUT
 * @param remainingStatic - additional static accounts that are not in a LUT
 */
function totalSize(staticAccountSize, lutCount, includedAccounts, remainingStatic) {
    const staticCount = staticAccountSize.staticAccounts + remainingStatic;
    return (staticAccountSize.staticSize +
        34 * lutCount + // lut key, writable len, readable len
        includedAccounts + // byte for each account index in the LUT
        lengthToCompact16size(staticCount) + // size of unique static keys
        staticCount * 32);
}
const insert = (arr, index, newItem) => [
    // part of the array before the specified index
    ...arr.slice(0, index),
    // inserted item
    newItem,
    // part of the array after the specified index
    ...arr.slice(index),
];
exports.insert = insert;
const deepCopyInstructions = (instructions) => {
    return {
        instructions: instructions.instructions.map((entry) => (Object.assign(Object.assign({}, entry), { instruction: new web3_js_1.TransactionInstruction({
                keys: entry.instruction.keys.map((k) => (Object.assign({}, k))),
                programId: entry.instruction.programId,
                data: entry.instruction.data
                    ? Buffer.from(entry.instruction.data)
                    : undefined,
            }) }))),
        lookupTables: instructions.lookupTables,
    };
};
exports.deepCopyInstructions = deepCopyInstructions;
function buildLookupTableSet(lookupTables) {
    return lookupTables.map((lut) => {
        const addresses = lut.state.addresses.map((a) => a.toBase58());
        const set = new Set(addresses);
        return [set, lut];
    });
}
exports.buildLookupTableSet = buildLookupTableSet;
function getNextFullTransaction(instructions, feePayer, beforeIxs = [], afterIxs = [], lookupTables = [], maxInstructionCount = 64) {
    return __awaiter(this, void 0, void 0, function* () {
        const instructionsWithSigners = (yield Promise.all(instructions.map((ix) => ix(feePayer)))).flat();
        const beforeIxsWithSigners = (yield Promise.all(beforeIxs.map((ix) => ix(feePayer)))).flat();
        const afterIxsWithSigners = (yield Promise.all(afterIxs.map((ix) => ix(feePayer)))).flat();
        const lookupTableAddresses = buildLookupTableSet(lookupTables);
        let current = {
            instructions: [...beforeIxsWithSigners, ...afterIxsWithSigners],
            lookupTables: [],
        };
        const { size: currentSize, lookupTables: currentLuts, uniqueKeyCount, } = getTransactionSize(current.instructions, feePayer.publicKey(), lookupTableAddresses);
        if (currentSize > exports.MAX_TRANSACTION_SIZE) {
            return (0, neverthrow_1.err)('Before and after instructions alone are too big to fit in transaction');
        }
        else if (uniqueKeyCount > exports.MAX_UNIQUE_KEYS_COUNT) {
            return (0, neverthrow_1.err)('Before and after instructions alone have too many unique keys to fit in transaction');
        }
        current.lookupTables = currentLuts;
        let popCount = 0;
        for (const ix of instructionsWithSigners) {
            const nextIxs = (0, exports.insert)(current.instructions, current.instructions.length - afterIxsWithSigners.length, ix);
            const { size: nextSize, lookupTables: nextLuts, uniqueKeyCount: nextUniqueKeyCount, } = getTransactionSize(nextIxs, feePayer.publicKey(), lookupTableAddresses);
            if (nextSize > exports.MAX_TRANSACTION_SIZE ||
                nextUniqueKeyCount > exports.MAX_UNIQUE_KEYS_COUNT ||
                nextIxs.length > maxInstructionCount) {
                if (popCount === 0) {
                    return (0, neverthrow_1.err)('Only the before and after instructions fit');
                }
                return (0, neverthrow_1.ok)([(0, exports.deepCopyInstructions)(current), popCount]);
            }
            else {
                popCount++;
                current = {
                    instructions: nextIxs,
                    lookupTables: nextLuts,
                };
            }
        }
        return (0, neverthrow_1.ok)([(0, exports.deepCopyInstructions)(current), popCount]);
    });
}
exports.getNextFullTransaction = getNextFullTransaction;
function buildDynamicTransactionsNoSigning(instructions, feePayer, beforeIxs = [], afterIxs = [], lookupTables = [], maxInstructionCount = 64) {
    return __awaiter(this, void 0, void 0, function* () {
        const instructionsWithSigners = (0, util_1.normalizeArray)(yield Promise.all((0, util_1.normalizeArray)(instructions).map((ix) => ix(feePayer)))).flat();
        const beforeIxsWithSigners = (0, util_1.normalizeArray)(yield Promise.all((0, util_1.normalizeArray)(beforeIxs).map((ix) => ix(feePayer)))).flat();
        const afterIxsWithSigners = (0, util_1.normalizeArray)(yield Promise.all((0, util_1.normalizeArray)(afterIxs).map((ix) => ix(feePayer)))).flat();
        const output = [];
        const lookupTableAddresses = buildLookupTableSet(lookupTables);
        let current = {
            instructions: [...beforeIxsWithSigners, ...afterIxsWithSigners],
            lookupTables: [],
        };
        const { size: currentSize, lookupTables: currentLuts, uniqueKeyCount, } = getTransactionSize(current.instructions, feePayer.publicKey(), lookupTableAddresses);
        if (currentSize > exports.MAX_TRANSACTION_SIZE) {
            return (0, neverthrow_1.err)('Before and after instructions alone are too big to fit in transaction');
        }
        else if (uniqueKeyCount > exports.MAX_UNIQUE_KEYS_COUNT) {
            return (0, neverthrow_1.err)('Before and after instructions alone have too many unique keys to fit in transaction');
        }
        current.lookupTables = currentLuts;
        for (const ix of instructionsWithSigners) {
            const nextIxs = (0, exports.insert)(current.instructions, current.instructions.length - afterIxsWithSigners.length, ix);
            const { size: nextSize, lookupTables: nextLuts, uniqueKeyCount: nextUniqueKeyCount, } = getTransactionSize(nextIxs, feePayer.publicKey(), lookupTableAddresses);
            if (nextSize > exports.MAX_TRANSACTION_SIZE ||
                nextUniqueKeyCount > exports.MAX_UNIQUE_KEYS_COUNT ||
                nextIxs.length > maxInstructionCount) {
                output.push((0, exports.deepCopyInstructions)(current));
                const currentIxs = [...beforeIxsWithSigners, ix, ...afterIxsWithSigners];
                const { size: currentSize, lookupTables: currentLuts, uniqueKeyCount: currentUniqueKeyCount, } = getTransactionSize(currentIxs, feePayer.publicKey(), lookupTableAddresses);
                if (currentSize > exports.MAX_TRANSACTION_SIZE) {
                    return (0, neverthrow_1.err)(`Instruction too large to fit in transaction: ${ix.instruction.programId.toBase58()}`);
                }
                else if (currentUniqueKeyCount > exports.MAX_UNIQUE_KEYS_COUNT) {
                    return (0, neverthrow_1.err)(`Instruction has too many unique accounts to fit in transaction: ${ix.instruction.programId.toBase58()}`);
                }
                else {
                    current = {
                        instructions: currentIxs,
                        lookupTables: currentLuts,
                    };
                }
            }
            else {
                current = {
                    instructions: nextIxs,
                    lookupTables: nextLuts,
                };
            }
        }
        if (current.instructions.length >
            beforeIxsWithSigners.length + afterIxsWithSigners.length) {
            output.push((0, exports.deepCopyInstructions)(current));
        }
        return (0, neverthrow_1.ok)(output);
    });
}
exports.buildDynamicTransactionsNoSigning = buildDynamicTransactionsNoSigning;
/**
 * Builds dynamic transactions from a set of instructions, fee payer, connection, and optional before/after instructions.
 *
 * @param instructions - The main instructions to include in the transactions.
 * @param feePayer - The fee payer for the transactions.
 * @param connectionOrRbh - The connection information or recent blockhash with expiry and commitment.
 * @param beforeIxs - Optional instructions to include at the beginning of each transaction.
 * @param afterIxs - Optional instructions to include at the end of each transaction.
 * @param lookupTables - Optional list of lookup tables to try to build transactions with.
 * @param maxInstructionCount - The maximum number of instructions to include in each transaction.
 * @returns A promise that resolves to a result object containing either the built transactions or an error message.
 */
function buildDynamicTransactions(instructions, feePayer, connectionOrRbh, beforeIxs = [], afterIxs = [], lookupTables = [], maxInstructionCount = 64) {
    return __awaiter(this, void 0, void 0, function* () {
        const output = yield buildDynamicTransactionsNoSigning(instructions, feePayer, beforeIxs, afterIxs, lookupTables, maxInstructionCount);
        if (output.isErr()) {
            return (0, neverthrow_1.err)(output.error);
        }
        const transactions = output.value.map((ixs) => ({
            ixs: ixs.instructions,
            connectionOrRbh,
            lookupTables: ixs.lookupTables,
        }));
        return (0, neverthrow_1.ok)(yield (0, transactionHandling_1.buildAndSignTransactionsFromIxWithSigners)(transactions, feePayer));
    });
}
exports.buildDynamicTransactions = buildDynamicTransactions;
function lengthToCompact16size(size) {
    if (size > 0x7f) {
        return 2;
    }
    else {
        return 1;
    }
}
//# sourceMappingURL=sizing.js.map