"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCurrentTimestampOnChain = exports.readMultipleFromRPC = exports.airdrop = exports.accountRPCSubscribe = exports.readFromRPCNullable = exports.readFromRPCOrError = exports.readFromRPC = exports.readAllFromRPC = exports.buildRPCDataSource = void 0;
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@staratlas/anchor");
const bs58_1 = __importDefault(require("bs58"));
const lodash_1 = require("lodash");
const util_1 = require("./util");
function buildRPCDataSource(connection) {
    const programs = {
        programs: [],
    };
    const handler = (program, confirmation, startup) => (account, context) => {
        program.provideAccountEvent(account, context.slot, confirmation, startup, 0);
    };
    return {
        insertProgram(program, startupCommitment, skipStartupDump = false) {
            return __awaiter(this, void 0, void 0, function* () {
                if (programs.programs === null) {
                    throw new Error('Data source closed');
                }
                if (startupCommitment === 'recent') {
                    throw new Error('RPC Data Source does not support recent');
                }
                const array = (0, util_1.fixedSizeArrayFromArray)(3, [
                    connection.onProgramAccountChange(program.programId, handler(program, 'processed', false), 'processed'),
                    connection.onProgramAccountChange(program.programId, handler(program, 'confirmed', false), 'confirmed'),
                    connection.onProgramAccountChange(program.programId, handler(program, 'finalized', false), 'finalized'),
                ]);
                if (array === null) {
                    throw new Error('Could not create listener array');
                }
                const index = programs.programs.length;
                const refresh = () => __awaiter(this, void 0, void 0, function* () {
                    if (programs.programs === null) {
                        return;
                    }
                    const program = programs.programs[index];
                    if (!program) {
                        return;
                    }
                    const { program: listenProgram } = program;
                    const accounts = yield connection.getProgramAccounts(listenProgram.programId, startupCommitment);
                    for (const account of accounts) {
                        listenProgram.provideAccountEvent({ accountId: account.pubkey, accountInfo: account.account }, 0, startupCommitment, true, 0);
                    }
                });
                programs.programs.push({ program, listenerId: array, refresh });
                if (!skipStartupDump) {
                    yield refresh();
                }
                return {
                    close: () => __awaiter(this, void 0, void 0, function* () {
                        if (programs.programs === null) {
                            return;
                        }
                        const program = programs.programs[index];
                        if (!program) {
                            return;
                        }
                        const { listenerId } = program;
                        programs.programs[index] = null;
                        yield Promise.all([
                            connection.removeProgramAccountChangeListener(listenerId[0]),
                            connection.removeProgramAccountChangeListener(listenerId[1]),
                            connection.removeProgramAccountChangeListener(listenerId[2]),
                        ]);
                    }),
                    refresh,
                };
            });
        },
        closeDataSource() {
            return __awaiter(this, void 0, void 0, function* () {
                if (programs.programs === null) {
                    throw new Error('Data source already closed');
                }
                const promises = [];
                for (const listenerId of programs.programs
                    .filter((p) => p !== null)
                    .flatMap((p) => p.listenerId)) {
                    try {
                        promises.push(connection.removeAccountChangeListener(listenerId));
                    }
                    catch (e) {
                        console.error('Could not remove listener: ', e);
                    }
                }
                programs.programs = null;
                yield Promise.all(promises);
            });
        },
        refreshAll() {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                yield Promise.all((_b = (_a = programs.programs) === null || _a === void 0 ? void 0 : _a.map((p) => p === null || p === void 0 ? void 0 : p.refresh())) !== null && _b !== void 0 ? _b : []);
            });
        },
    };
}
exports.buildRPCDataSource = buildRPCDataSource;
function readAllFromRPC(connection, program, accountClass, commitment, additionalFilters = []) {
    return __awaiter(this, void 0, void 0, function* () {
        const accounts = yield connection.getProgramAccounts(program.programId, Object.assign(Object.assign({}, (commitment ? { commitment } : {})), { filters: [
                {
                    memcmp: {
                        offset: 0,
                        bytes: bs58_1.default.encode(anchor_1.BorshAccountsCoder.accountDiscriminator(accountClass.ACCOUNT_NAME)),
                    },
                },
                ...additionalFilters,
            ] }));
        return accounts.map((account) => accountClass.decodeData({ accountInfo: account.account, accountId: account.pubkey }, program));
    });
}
exports.readAllFromRPC = readAllFromRPC;
function readFromRPC(connection, program, key, accountClass, commitment) {
    return __awaiter(this, void 0, void 0, function* () {
        const account = yield connection.getAccountInfo(key, commitment);
        if (account === null) {
            return {
                type: 'error',
                key,
                error: new Error('account does not exist'),
            };
        }
        else {
            return accountClass.decodeData({ accountInfo: account, accountId: key }, program);
        }
    });
}
exports.readFromRPC = readFromRPC;
function readFromRPCOrError(connection, program, key, accountClass, commitment) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield readFromRPC(connection, program, key, accountClass, commitment);
        if ('error' in result) {
            throw result.error;
        }
        return result.data;
    });
}
exports.readFromRPCOrError = readFromRPCOrError;
function readFromRPCNullable(connection, program, key, accountClass, commitment) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield readFromRPC(connection, program, key, accountClass, commitment);
        if ('error' in result) {
            return null;
        }
        else {
            return result.data;
        }
    });
}
exports.readFromRPCNullable = readFromRPCNullable;
function accountRPCSubscribe(connection, program, key, accountClass, callback, commitment) {
    return connection.onAccountChange(key, (account) => {
        callback(accountClass.decodeData({ accountInfo: account, accountId: key }, program));
    }, commitment);
}
exports.accountRPCSubscribe = accountRPCSubscribe;
function airdrop(connection, wallet, lamports = web3_js_1.LAMPORTS_PER_SOL, commitment) {
    return __awaiter(this, void 0, void 0, function* () {
        const sig = yield connection.requestAirdrop(wallet, lamports);
        yield connection.confirmTransaction(sig, commitment);
        return sig;
    });
}
exports.airdrop = airdrop;
/**
 * Read multiple accounts from the RPC
 * @param accountsToRead - array of keys of accounts to read
 * @param connection - Solana connection object
 * @param program - the program that owns the accounts
 * @param accountClass - the account class
 * @param commitment - the Solana commitment level
 * @returns an array of the decoded accounts
 */
function readMultipleFromRPC(accountsToRead, connection, program, accountClass, commitment) {
    return __awaiter(this, void 0, void 0, function* () {
        /** getMultipleAccountsInfo is limited to 100 at a time */
        const result = (yield Promise.all((0, lodash_1.chunk)(accountsToRead, 100).map((it) => connection.getMultipleAccountsInfo(it, commitment)))).flat();
        const accounts = [];
        for (let index = 0; index < result.length; index++) {
            const account = result[index];
            const accountId = accountsToRead[index];
            if (account) {
                accounts.push(accountClass.decodeData({ accountInfo: account, accountId }, program));
            }
        }
        return accounts;
    });
}
exports.readMultipleFromRPC = readMultipleFromRPC;
/**
 * Get current timestamp on chain
 * @param connection - the Solana connection object
 * @returns current timestamp on chain
 */
const getCurrentTimestampOnChain = (connection) => __awaiter(void 0, void 0, void 0, function* () {
    const clock = yield connection.getAccountInfo(web3_js_1.SYSVAR_CLOCK_PUBKEY);
    if (clock === null) {
        throw 'Failed to fetch Clock account info';
    }
    return clock.data.readBigInt64LE(8 * 4);
});
exports.getCurrentTimestampOnChain = getCurrentTimestampOnChain;
//# sourceMappingURL=rpc.js.map