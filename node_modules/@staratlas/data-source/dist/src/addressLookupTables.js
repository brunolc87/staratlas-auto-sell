"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAndExtendAddressLookupTable = exports.extendAddressLookupTable = exports.createAddressLookupTable = void 0;
const web3_js_1 = require("@solana/web3.js");
const neverthrow_1 = require("neverthrow");
const transactions_1 = require("./transactions");
function createAddressLookupTable(connection, authority, feePayer, recentSlot, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const [createLutIx, newLutKey] = web3_js_1.AddressLookupTableProgram.createLookupTable({
            authority: authority.publicKey(),
            payer: feePayer.publicKey(),
            recentSlot: recentSlot !== null && recentSlot !== void 0 ? recentSlot : (yield connection.getSlot('confirmed')),
        });
        const builder = new transactions_1.TransactionBuilder({
            connection,
            commitment: 'confirmed',
            feePayer,
        }).add(createLutIx, [authority, feePayer]);
        const createTx = yield builder.buildAndSignOptimal();
        const txResponse = yield (0, transactions_1.sendTransaction)(createTx, connection, Object.assign(Object.assign({}, options), { 
            // Creating LUT fails in preflight check
            sendOptions: {
                skipPreflight: true,
            } }));
        if (txResponse.value.isErr()) {
            return (0, neverthrow_1.err)(`Failed to create address lookup table: ${txResponse.value.error}`);
        }
        return (0, neverthrow_1.ok)(newLutKey);
    });
}
exports.createAddressLookupTable = createAddressLookupTable;
const MS_PER_SLOT = 400;
function extendAddressLookupTable(connection, lookupTable, authority, feePayer, addresses, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (addresses.length > 256) {
            return (0, neverthrow_1.err)('Transaction lookup table can only hold up to 256 addresses');
        }
        const addressesClone = [...addresses];
        const instructions = [];
        while (addressesClone.length > 0) {
            const chunk = addressesClone.splice(0, 20);
            const extendLutIx = web3_js_1.AddressLookupTableProgram.extendLookupTable({
                lookupTable: lookupTable,
                authority: authority.publicKey(),
                payer: feePayer.publicKey(),
                addresses: chunk,
            });
            instructions.push(extendLutIx);
        }
        const instructionReturns = instructions.map((ix) => {
            return (payer) => Promise.resolve({
                instruction: ix,
                signers: [payer, feePayer, authority],
            });
        });
        const txReturns = yield new transactions_1.TransactionBuilder({
            connection,
            commitment: options === null || options === void 0 ? void 0 : options.commitment,
            feePayer,
        })
            .add(instructionReturns)
            .buildDynamic();
        if (txReturns.isErr()) {
            return new neverthrow_1.Err(`Failed to build dynamic transactions: ${txReturns.error}`);
        }
        const results = yield Promise.all(txReturns.value.map((txn) => {
            return (0, transactions_1.sendTransaction)(txn, connection, options);
        }));
        const error = results.find((txResponse) => txResponse.value.isErr());
        if (error) {
            return (0, neverthrow_1.err)(`Failed to extend address lookup table: ${error.value}`);
        }
        if (options === null || options === void 0 ? void 0 : options.awaitNewSlot) {
            const slots = results.map((txResponse) => txResponse.context.slot);
            const newestSlotNum = Math.max(...slots);
            // wait for 1 slot to pass for extended lookup table to be usable
            const commitment = (_a = options === null || options === void 0 ? void 0 : options.commitment) !== null && _a !== void 0 ? _a : 'confirmed';
            while ((yield connection.getSlot(commitment)) <= newestSlotNum) {
                yield new Promise((resolve) => setTimeout(resolve, MS_PER_SLOT / 2));
            }
        }
        return (0, neverthrow_1.ok)(lookupTable);
    });
}
exports.extendAddressLookupTable = extendAddressLookupTable;
function createAndExtendAddressLookupTable(connection, authority, feePayer, addresses, recentSlot, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const lookupTable = yield createAddressLookupTable(connection, authority, feePayer, recentSlot, options);
        if (lookupTable.isErr()) {
            return lookupTable;
        }
        return yield extendAddressLookupTable(connection, lookupTable.value, authority, feePayer, addresses, options);
    });
}
exports.createAndExtendAddressLookupTable = createAndExtendAddressLookupTable;
//# sourceMappingURL=addressLookupTables.js.map