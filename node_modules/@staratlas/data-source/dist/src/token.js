"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAssociatedTokenAccountIdempotent = exports.createAssociatedTokenAccount = exports.transferToTokenAccount = exports.setAccountAuthority = exports.setFreezeAuthority = exports.setMintAuthority = exports.mintToTokenAccount = exports.createTokenAccount = exports.createMint = exports.getParsedTokenAccountsByOwner = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const _1 = require(".");
/**
 * Fetch all the parsed token accounts owned by the specified account
 *
 * Better than `connection.getTokenAccountsByOwner` or `connection.getParsedTokenAccountsByOwner`
 * as it properly decodes the token accounts using the more modern `unpackAccount`.
 *
 * @param connection - Solana connection object
 * @param owner - the token accounts owner
 * @param programId - the token program id
 * @returns the parsed token accounts for the given owner
 */
const getParsedTokenAccountsByOwner = (connection, owner, programId = spl_token_1.TOKEN_PROGRAM_ID) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield connection.getTokenAccountsByOwner(owner, {
        programId,
    })).value.map((data) => (0, spl_token_1.unpackAccount)(data.pubkey, data.account, programId));
});
exports.getParsedTokenAccountsByOwner = getParsedTokenAccountsByOwner;
function createMint(mint, decimals, mintAuthority, freezeAuthority) {
    // eslint-disable-next-line require-await
    return (funder) => __awaiter(this, void 0, void 0, function* () {
        return [
            {
                instruction: web3_js_1.SystemProgram.createAccount({
                    fromPubkey: funder.publicKey(),
                    lamports: (0, _1.calculateMinimumRent)(spl_token_1.MINT_SIZE),
                    newAccountPubkey: mint.publicKey(),
                    programId: spl_token_1.TOKEN_PROGRAM_ID,
                    space: spl_token_1.MINT_SIZE,
                }),
                signers: [mint, funder],
            },
            {
                instruction: (0, spl_token_1.createInitializeMintInstruction)(mint.publicKey(), decimals, mintAuthority, freezeAuthority),
                signers: [],
            },
        ];
    });
}
exports.createMint = createMint;
function createTokenAccount(account, owner, mint) {
    // eslint-disable-next-line require-await
    return (funder) => __awaiter(this, void 0, void 0, function* () {
        return [
            {
                instruction: web3_js_1.SystemProgram.createAccount({
                    fromPubkey: funder.publicKey(),
                    lamports: (0, _1.calculateMinimumRent)(spl_token_1.ACCOUNT_SIZE),
                    newAccountPubkey: account.publicKey(),
                    programId: spl_token_1.TOKEN_PROGRAM_ID,
                    space: spl_token_1.ACCOUNT_SIZE,
                }),
                signers: [account, funder],
            },
            {
                instruction: (0, spl_token_1.createInitializeAccountInstruction)(account.publicKey(), mint, owner),
                signers: [],
            },
        ];
    });
}
exports.createTokenAccount = createTokenAccount;
function mintToTokenAccount(mintAuthority, mint, tokenAccount, amount) {
    // eslint-disable-next-line require-await
    return () => __awaiter(this, void 0, void 0, function* () {
        return ({
            instruction: (0, spl_token_1.createMintToInstruction)(mint, tokenAccount, mintAuthority.publicKey(), amount, []),
            signers: [mintAuthority],
        });
    });
}
exports.mintToTokenAccount = mintToTokenAccount;
function setMintAuthority(mint, currentAuthority, newAuthority) {
    // eslint-disable-next-line require-await
    return () => __awaiter(this, void 0, void 0, function* () {
        return ({
            instruction: (0, spl_token_1.createSetAuthorityInstruction)(mint, currentAuthority.publicKey(), spl_token_1.AuthorityType.MintTokens, newAuthority),
            signers: [currentAuthority],
        });
    });
}
exports.setMintAuthority = setMintAuthority;
function setFreezeAuthority(mint, currentFreezeAuthority, newFreezeAuthority) {
    // eslint-disable-next-line require-await
    return () => __awaiter(this, void 0, void 0, function* () {
        return ({
            instruction: (0, spl_token_1.createSetAuthorityInstruction)(mint, currentFreezeAuthority.publicKey(), spl_token_1.AuthorityType.FreezeAccount, newFreezeAuthority),
            signers: [currentFreezeAuthority],
        });
    });
}
exports.setFreezeAuthority = setFreezeAuthority;
function setAccountAuthority(tokenAccount, currentAuthority, newAuthority) {
    // eslint-disable-next-line require-await
    return () => __awaiter(this, void 0, void 0, function* () {
        return ({
            instruction: (0, spl_token_1.createSetAuthorityInstruction)(tokenAccount, currentAuthority.publicKey(), spl_token_1.AuthorityType.AccountOwner, newAuthority),
            signers: [currentAuthority],
        });
    });
}
exports.setAccountAuthority = setAccountAuthority;
function transferToTokenAccount(owner, source, destination, amount) {
    // eslint-disable-next-line require-await
    return () => __awaiter(this, void 0, void 0, function* () {
        return ({
            instruction: (0, spl_token_1.createTransferInstruction)(source, destination, owner.publicKey(), amount, []),
            signers: [owner],
        });
    });
}
exports.transferToTokenAccount = transferToTokenAccount;
/**
 * Create and initialize a new associated token account with allowOwnerOffCurve
 *
 * @param payer                    Payer of the transaction and initialization fees
 * @param mint                     Mint for the account
 * @param owner                    Owner of the new account
 * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)
 * @param programId                SPL Token program account
 * @param associatedTokenProgramId SPL Associated Token program account
 *
 * @return Address of the new associated token account
 */
function createAssociatedTokenAccount(mint, owner, allowOwnerOffCurve = true, programId = spl_token_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const associatedToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    return {
        // eslint-disable-next-line require-await
        instructions: (funder) => __awaiter(this, void 0, void 0, function* () {
            return ({
                instruction: (0, spl_token_1.createAssociatedTokenAccountInstruction)(funder.publicKey(), associatedToken, owner, mint, programId, associatedTokenProgramId),
                signers: [funder],
            });
        }),
        address: associatedToken,
    };
}
exports.createAssociatedTokenAccount = createAssociatedTokenAccount;
/**
 * Construct a CreateAssociatedTokenAccountIdempotent instruction
 *
 * Creates an associated token account for the given wallet address and token mint,
 * if it doesn't already exist.  Returns an error if the account exists,
 * but with a different owner.
 *
 * @param payer                    Payer of the transaction and initialization fees
 * @param mint                     Mint for the account
 * @param owner                    Owner of the new account
 * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)
 * @param programId                SPL Token program account
 * @param associatedTokenProgramId SPL Associated Token program account
 *
 * @return Address of the new associated token account
 */
function createAssociatedTokenAccountIdempotent(mint, owner, allowOwnerOffCurve = true, programId = spl_token_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const associatedToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    return {
        // eslint-disable-next-line require-await
        instructions: (funder) => __awaiter(this, void 0, void 0, function* () {
            return ({
                instruction: (0, spl_token_1.createAssociatedTokenAccountIdempotentInstruction)(funder.publicKey(), associatedToken, owner, mint, programId, associatedTokenProgramId),
                signers: [funder],
            });
        }),
        address: associatedToken,
    };
}
exports.createAssociatedTokenAccountIdempotent = createAssociatedTokenAccountIdempotent;
//# sourceMappingURL=token.js.map