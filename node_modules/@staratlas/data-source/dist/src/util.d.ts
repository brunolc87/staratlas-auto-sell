export declare function optionalToArray<T>(value: T | null | undefined): T[];
export type ExtractArrayType<T> = T extends Array<infer U> ? U : never;
export declare function remapObject<T extends Record<string, unknown>, O extends {
    [K in keyof T]: unknown;
}>(object: T, mapper: <K extends keyof T & string>(value: T[K], key: K) => O[K]): O;
type Shift<A extends Array<any>> = ((...args: A) => void) extends (...args: [A[0], ...infer R]) => void ? R : never;
type GrowExpRev<A extends Array<any>, N extends number, P extends Array<Array<any>>> = A['length'] extends N ? A : {
    0: GrowExpRev<[...A, ...P[0]], N, P>;
    1: GrowExpRev<A, N, Shift<P>>;
}[[...A, ...P[0]][N] extends undefined ? 0 : 1];
type GrowExp<A extends Array<any>, N extends number, P extends Array<Array<any>>> = A['length'] extends N ? A : {
    0: GrowExp<[...A, ...A], N, [A, ...P]>;
    1: GrowExpRev<A, N, P>;
}[[...A, ...A][N] extends undefined ? 0 : 1];
export type FixedSizeArray<T, N extends number> = N extends 0 ? [] : N extends 1 ? [T] : GrowExp<[T, T], N, [[T]]>;
export declare function fixedSizeArray<T, N extends number>(length: N, initialValue: T): FixedSizeArray<T, N>;
export declare function fixedSizeArrayInit<T, N extends number>(length: N, init: (index: number) => T): FixedSizeArray<T, N>;
/**
 * @param length The length for the fixed size array.
 * @param array The array to try to convert.
 * @return `null` if array is the incorrect size.
 */
export declare function fixedSizeArrayFromArray<T, N extends number>(length: N, array: T[]): FixedSizeArray<T, N> | null;
export declare function arrayDeepEquals<T, U>(array1: Readonly<T[]>, array2: Readonly<U[]>, eq: (a: T, b: U) => boolean): boolean;
export declare function stringToByteArray(input: string, forceSize?: number): number[];
export declare function byteArrayToString(input: number[]): string;
export declare function assertNever(x: never): never;
/**
 * Class decorator
 */
export declare function staticImplements<T>(): <U extends T>(constructor: U) => void;
/** Check if all Object Properties are Null */
export declare const isNull: <T>(obj: keyof T extends string ? { [K in keyof T]: T[K]; } : never) => boolean;
export type CUnion<T extends Record<PropertyKey, unknown>> = {
    [K in keyof T]: {
        [_ in K]: T[K];
    } & {
        [_ in Exclude<keyof T, K>]?: undefined;
    };
}[keyof T];
/** Gets the element at `index` on the array or throws an error if it is not defined */
export declare const getElementOrError: <T>(array: T[], index: number) => T;
export interface CustomAnchorError {
    InstructionError: [number, {
        Custom: number;
    }];
}
export declare function normalizeArray<T>(val: T | T[]): T[];
export declare const snakeCaseToTitleCase: (text: string) => string;
export declare const ACCOUNT_STORAGE_OVERHEAD = 128;
export declare const LAMPORTS_PER_BYTE_YEAR: number;
export declare const EXEMPTION_THRESHOLD = 2;
export declare function calculateMinimumRent(dataSize: number): number;
export {};
//# sourceMappingURL=util.d.ts.map