/// <reference types="node" />
import { AccountInfo, KeyedAccountInfo, PublicKey, TransactionConfirmationStatus } from '@solana/web3.js';
import { Coder, Idl, Program, Provider } from '@staratlas/anchor';
import { Account, AccountStatic } from './account';
export type ProgramMethods<IDL extends Idl> = Omit<Program<IDL>, 'provider' | 'addEventListener' | 'removeEventListener' | 'rpc' | 'account'>;
export type AccountUpdate<T> = {
    slot: number;
    writeVersion: number;
    isStartup: boolean;
    confirmationStatus: TransactionConfirmationStatus | 'recent';
    account: T;
    accountInfo: AccountInfo<Buffer>;
};
export type AccountClosedUpdate = {
    slot: number;
    writeVersion: number;
    confirmationStatus: TransactionConfirmationStatus | 'recent';
    key: PublicKey;
    oldOwner: PublicKey;
    newOwner: PublicKey;
    accountInfo: AccountInfo<Buffer>;
};
export type AccountUpdateHandler<T> = (update: AccountUpdate<T>) => void;
export declare abstract class ListenProgram<Accounts extends Record<string, Account>, IDL extends Idl> {
    protected program: ProgramMethods<IDL>;
    protected parsers: {
        [K in keyof Accounts & string]: {
            new (...args: never[]): Accounts[K] & Account;
        } & AccountStatic<Accounts[K], IDL>;
    };
    private readonly listeners;
    protected readonly accountDiscriminants: {
        [K in keyof Accounts]: Readonly<Buffer>;
    };
    protected accountClosedListener: ((update: AccountClosedUpdate) => void) | null;
    protected constructor(program: ProgramMethods<IDL>, parsers: {
        [K in keyof Accounts & string]: {
            new (...args: never[]): Accounts[K] & Account;
        } & AccountStatic<Accounts[K], IDL>;
    });
    setAccountClosedListener(listener: (update: AccountClosedUpdate) => void | null): void;
    get programId(): PublicKey;
    accountDiscriminant(accountId: keyof Accounts): Buffer;
    discriminantToAccountId(data: Buffer): {
        key: keyof Accounts & string;
        discriminantLength: number;
    } | null;
    provideDecodedAccountEvent<AccountId extends keyof Accounts>(accountId: AccountId, account: Accounts[AccountId], slot: number, confirmationStatus: TransactionConfirmationStatus | 'recent', isStartup: boolean, accountInfo: AccountInfo<Buffer>, writeVersion: number): void;
    provideAccountEvent(account: KeyedAccountInfo, slot: number, confirmationStatus: TransactionConfirmationStatus | 'recent', isStartup: boolean, writeVersion: number, unknownAccountHandler?: (key: PublicKey) => void): void;
    setAccountListener<AccountId extends keyof Accounts>(accountId: AccountId, accountType: {
        new (...args: never[]): Accounts[AccountId];
    }, listener: AccountUpdateHandler<Accounts[AccountId]> | null): void;
    discriminantToAccountIdNoSubarray(discriminant: Buffer): {
        key: keyof Accounts & string;
        discriminantLength: number;
    } | null;
    provideAccountClosedEvent(key: PublicKey, oldOwner: PublicKey, newOwner: PublicKey, slot: number, confirmationStatus: TransactionConfirmationStatus | 'recent', writeVersion: number, accountInfo: AccountInfo<Buffer>): void;
}
export interface ListenProgramStatic<Self, Accounts extends Record<string, Account>, IDL extends Idl> {
    new (program: ProgramMethods<IDL>): Self & ListenProgram<Accounts, IDL>;
    buildProgram(programId: PublicKey, provider?: Provider, coder?: Coder): ProgramMethods<IDL>;
}
//# sourceMappingURL=listenProgam.d.ts.map