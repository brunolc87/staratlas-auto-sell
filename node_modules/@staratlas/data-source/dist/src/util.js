"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMinimumRent = exports.EXEMPTION_THRESHOLD = exports.LAMPORTS_PER_BYTE_YEAR = exports.ACCOUNT_STORAGE_OVERHEAD = exports.snakeCaseToTitleCase = exports.normalizeArray = exports.getElementOrError = exports.isNull = exports.staticImplements = exports.assertNever = exports.byteArrayToString = exports.stringToByteArray = exports.arrayDeepEquals = exports.fixedSizeArrayFromArray = exports.fixedSizeArrayInit = exports.fixedSizeArray = exports.remapObject = exports.optionalToArray = void 0;
const lodash_1 = require("lodash");
function optionalToArray(value) {
    if (value === null || value === undefined) {
        return [];
    }
    else {
        return [value];
    }
}
exports.optionalToArray = optionalToArray;
function remapObject(object, mapper) {
    return Object.entries(object)
        .map(([key, value]) => ({
        [key]: mapper(value, key),
    }))
        .reduce((prev, next) => (Object.assign(Object.assign({}, prev), next)));
}
exports.remapObject = remapObject;
function fixedSizeArray(length, initialValue) {
    return new Array(length).fill(initialValue);
}
exports.fixedSizeArray = fixedSizeArray;
function fixedSizeArrayInit(length, init) {
    return (0, lodash_1.range)(0, length).map(init);
}
exports.fixedSizeArrayInit = fixedSizeArrayInit;
/**
 * @param length The length for the fixed size array.
 * @param array The array to try to convert.
 * @return `null` if array is the incorrect size.
 */
function fixedSizeArrayFromArray(length, array) {
    if (array.length === length) {
        return array;
    }
    else {
        return null;
    }
}
exports.fixedSizeArrayFromArray = fixedSizeArrayFromArray;
function arrayDeepEquals(array1, array2, eq) {
    if (array1.length !== array2.length) {
        return false;
    }
    return array1.reduce((prev, current, index) => {
        const other = array2[index];
        if (other == null) {
            return false;
        }
        return prev && eq(current, other);
    }, true);
}
exports.arrayDeepEquals = arrayDeepEquals;
function stringToByteArray(input, forceSize) {
    const nameBytes = new TextEncoder().encode(input);
    if (forceSize === undefined) {
        return Array.from(nameBytes);
    }
    else {
        if (nameBytes.length > forceSize) {
            throw new Error('name too long');
        }
        return Array.from(nameBytes).concat(new Array(forceSize - nameBytes.length).fill(0));
    }
}
exports.stringToByteArray = stringToByteArray;
function byteArrayToString(input) {
    const firstZero = input.findIndex((x) => x === 0);
    return new TextDecoder().decode(Uint8Array.from(input).slice(0, firstZero === -1 ? undefined : firstZero));
}
exports.byteArrayToString = byteArrayToString;
function assertNever(x) {
    throw new Error('Unexpected object: ' + x);
}
exports.assertNever = assertNever;
/**
 * Class decorator
 */
function staticImplements() {
    return (constructor) => {
        // noinspection BadExpressionStatementJS
        constructor;
    };
}
exports.staticImplements = staticImplements;
/** Check if all Object Properties are Null */
const isNull = (obj) => {
    return Object.values(obj).every((value) => value === null);
};
exports.isNull = isNull;
/** Gets the element at `index` on the array or throws an error if it is not defined */
const getElementOrError = (array, index) => {
    const el = array[index];
    if (el == null) {
        throw new Error(`element at index ${index} doesn't exist in ${typeof array}`);
    }
    return el;
};
exports.getElementOrError = getElementOrError;
function normalizeArray(val) {
    return Array.isArray(val) ? val : [val];
}
exports.normalizeArray = normalizeArray;
const snakeCaseToTitleCase = (text) => {
    const result = text.replace(/([A-Z])/g, ' $1');
    return result.charAt(0).toUpperCase() + result.slice(1);
};
exports.snakeCaseToTitleCase = snakeCaseToTitleCase;
exports.ACCOUNT_STORAGE_OVERHEAD = 128;
exports.LAMPORTS_PER_BYTE_YEAR = ((1000000000 / 100) * 365) / (1024 * 1024);
exports.EXEMPTION_THRESHOLD = 2;
function calculateMinimumRent(dataSize) {
    return ((exports.ACCOUNT_STORAGE_OVERHEAD + dataSize) *
        exports.LAMPORTS_PER_BYTE_YEAR *
        exports.EXEMPTION_THRESHOLD);
}
exports.calculateMinimumRent = calculateMinimumRent;
//# sourceMappingURL=util.js.map