/// <reference types="node" />
import { KeyedAccountInfo, PublicKey } from '@solana/web3.js';
import { Idl } from '@staratlas/anchor';
import { ProgramMethods } from './listenProgam';
export type DecodedAccountData<T> = {
    type: 'ok';
    key: PublicKey;
    data: T;
} | {
    type: 'error';
    key: PublicKey;
    error: Error;
};
export interface Account {
    get key(): PublicKey;
}
export interface AccountStatic<Self extends Account, IDL extends Idl> {
    /** should be in camelCase */
    readonly ACCOUNT_NAME: NonNullable<IDL['accounts']>[number]['name'];
    /** The size of any header data and discriminant */
    readonly MIN_DATA_SIZE: number;
    new (...args: never[]): Self & Account;
    decodeData(account: KeyedAccountInfo, program: ProgramMethods<IDL>): DecodedAccountData<Self>;
}
interface ToBufferInterface {
    toBuffer: () => Buffer;
}
export type ToBuffer = ToBufferInterface | PublicKey | Buffer | Uint8Array | string;
export interface PdaAccountStatic<Self extends Account, IDL extends Idl, SeedsArgs extends Record<string, ToBuffer>> extends AccountStatic<Self, IDL> {
    findAddress(program: ProgramMethods<IDL>, args: SeedsArgs): [PublicKey, number];
}
export declare function decodeAccount<A extends Account, D, IDL extends Idl>(account: KeyedAccountInfo, program: ProgramMethods<IDL>, accountClass: AccountStatic<A, IDL> & (new (data: D, key: PublicKey) => A)): DecodedAccountData<A>;
export declare function decodeAccountWithRemaining<A extends Account, D, R, IDL extends Idl>(account: KeyedAccountInfo, program: ProgramMethods<IDL>, accountClass: AccountStatic<A, IDL> & (new (data: D, key: PublicKey, remainingData: R) => A), remainingDataFunc: (remainingData: Buffer, data: D) => R): DecodedAccountData<A>;
export {};
//# sourceMappingURL=account.d.ts.map