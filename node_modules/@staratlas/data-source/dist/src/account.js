"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeAccountWithRemaining = exports.decodeAccount = void 0;
const anchor_1 = require("@staratlas/anchor");
function decodeAccount(account, program, accountClass) {
    if (!account.accountInfo.owner.equals(program.programId)) {
        return {
            type: 'error',
            key: account.accountId,
            error: new Error('not owned by program'),
        };
    }
    else if (!account.accountInfo.data
        .subarray(0, 8)
        .equals(anchor_1.BorshAccountsCoder.accountDiscriminator(accountClass.ACCOUNT_NAME))) {
        return {
            type: 'error',
            key: account.accountId,
            error: new Error('discriminator mismatch'),
        };
    }
    else {
        try {
            const coder = program.coder;
            const data = coder.accounts.decode(accountClass.ACCOUNT_NAME, account.accountInfo.data);
            return {
                type: 'ok',
                key: account.accountId,
                data: new accountClass(data, account.accountId),
            };
        }
        catch (error) {
            return {
                type: 'error',
                key: account.accountId,
                error: error,
            };
        }
    }
}
exports.decodeAccount = decodeAccount;
function decodeAccountWithRemaining(account, program, accountClass, remainingDataFunc) {
    if (!account.accountInfo.owner.equals(program.programId)) {
        return {
            type: 'error',
            key: account.accountId,
            error: new Error('not owned by program'),
        };
    }
    else if (!account.accountInfo.data
        .subarray(0, 8)
        .equals(anchor_1.BorshAccountsCoder.accountDiscriminator(accountClass.ACCOUNT_NAME))) {
        return {
            type: 'error',
            key: account.accountId,
            error: new Error('discriminator mismatch'),
        };
    }
    else {
        try {
            const coder = program.coder;
            const data = coder.accounts.decode(accountClass.ACCOUNT_NAME, account.accountInfo.data.subarray(0, accountClass.MIN_DATA_SIZE));
            return {
                type: 'ok',
                key: account.accountId,
                data: new accountClass(data, account.accountId, remainingDataFunc(account.accountInfo.data.subarray(accountClass.MIN_DATA_SIZE), data)),
            };
        }
        catch (error) {
            return {
                type: 'error',
                key: account.accountId,
                error: error,
            };
        }
    }
}
exports.decodeAccountWithRemaining = decodeAccountWithRemaining;
//# sourceMappingURL=account.js.map